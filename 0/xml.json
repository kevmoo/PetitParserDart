{"dependencies":[{"id":"dart.core","name":"dart:core","children":[{"id":"Object","name":"Object","children":[{"isOperator":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"==1()","name":"==","children":[{"id":"other","name":"other","kind":"param"}],"kind":"method","comment":"\nThe equality operator.\n\nThe default behavior for all [Object]s is to return true if and\nonly if [:this:] and [other] are the same object.\n\nIf a subclass overrides the equality operator it should override\nthe [hashCode] method as well to maintain consistency.\n","line":"29"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"toString0()","name":"toString","kind":"method","comment":"\nReturns a string representation of this object.\n","line":"48"},{"id":"noSuchMethod1()","name":"noSuchMethod","children":[{"ref":{"name":"InvocationMirror","refId":"dart.core/InvocationMirror"},"id":"invocation","name":"invocation","kind":"param"}],"kind":"method","comment":"\n[noSuchMethod] is invoked when users invoke a non-existant method\non an object. The name of the method and the arguments of the\ninvocation are passed to [noSuchMethod] in an [InvocationMirror].\nIf [noSuchMethod] returns a value, that value becomes the result of\nthe original invocation.\n\nThe default behavior of [noSuchMethod] is to throw a\n[noSuchMethodError].\n","line":"60"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"hashCode","name":"hashCode","kind":"property","comment":"\nGet a hash code for this object.\n\nAll objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator [:==:]. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.\n\nIf a subclass overrides [hashCode] it should override the\nequality operator as well to maintain consistency.\n","line":"43"},{"ref":{"name":"Type","refId":"dart.core/Type"},"id":"runtimeType","name":"runtimeType","kind":"property","comment":"\nA representation of the runtime type of the object.\n","line":"65"},{"id":"Object0()","name":"Object","kind":"constructor","comment":"\nCreates a new [Object] instance.\n\n[Object] instances have no meaningful state, and are only useful\nthrough their identity. An [Object] instance is equal to itself\nonly.\n","line":"18"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/object.dart","kind":"class","comment":"\nEverything in Dart is an [Object].\n","line":"10"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"id":"Iterable","name":"Iterable","children":[{"returnType":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"map1()","name":"map","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"param","line":"51"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns a lazy [Iterable] where each element [:e:] of [this] is replaced\nby the result of [:f(e):].\n\nThis method returns a view of the mapped elements. As long as the\nreturned [Iterable] is not iterated over, the supplied function [f] will\nnot be invoked. The transformed elements will not be cached. Iterating\nmultiple times over the the returned [Iterable] will invoke the supplied\nfunction [f] multiple times on the same element.\n","line":"51"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"where1()","name":"where","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"param","line":"63"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns a lazy [Iterable] with all elements that satisfy the\npredicate [f].\n\nThis method returns a view of the mapped elements. As long as the\nreturned [Iterable] is not iterated over, the supplied function [f] will\nnot be invoked. Iterating will not cache results, and thus iterating\nmultiple times over the the returned [Iterable] will invoke the supplied\nfunction [f] multiple times on the same element.\n","line":"63"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"expand1()","name":"expand","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"returnType":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"param","line":"75"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nExpand each element of this [Iterable] into zero or more elements.\n\nThe resulting Iterable will run through the elements returned\nby [f] for each element of this, in order.\n\nThe returned [Iterable] is lazy, and will call [f] for each element\nof this every time it's iterated.\n","line":"75"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"contains1()","name":"contains","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","kind":"param"}],"kind":"method","comment":"\nCheck whether the collection contains an element equal to [element].\n","line":"81"},{"returnType":{"name":"void","refId":"void"},"id":"forEach1()","name":"forEach","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"returnType":{"name":"void","refId":"void"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"param","line":"91"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nApplies the function [f] to each element of this collection.\n","line":"91"},{"id":"reduce2()","name":"reduce","children":[{"id":"initialValue","name":"initialValue","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"combine","name":"combine","children":[{"id":"Function","name":"Function","children":[{"id":"previousValue","name":"previousValue","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"param","line":"106"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"param","line":"106"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param","line":"106"}],"kind":"method","comment":"\nReduce a collection to a single value by iteratively combining each element\nof the collection with an existing value using the provided function.\nUse [initialValue] as the initial value, and the function [combine] to\ncreate a new value from the previous one and an element.\n\nExample of calculating the sum of a collection:\n\n  collection.reduce(0, (prev, element) => prev + element);\n","line":"105"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"every1()","name":"every","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"param","line":"116"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns true if every elements of this collection satisify the\npredicate [f]. Returns false otherwise.\n","line":"116"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"join1()","name":"join","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"separator","name":"separator","kind":"param"}],"kind":"method","comment":"\nConvert each element to a [String] and concatenate the strings.\n\nConverts each element to a [String] by calling [Object.toString] on it.\nThen concatenates the strings, optionally separated by the [separator]\nstring.\n","line":"130"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"any1()","name":"any","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"param","line":"152"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns true if one element of this collection satisfies the\npredicate [f]. Returns false otherwise.\n","line":"152"},{"returnType":{"name":"List","refId":"dart.core/List","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"toList1()","name":"toList","children":[{"ref":{"name":"bool","refId":"dart.core/bool"},"isNamed":true,"defaultValue":"true","isOptional":true,"id":"growable","name":"growable","kind":"param"}],"kind":"method","line":"159"},{"returnType":{"name":"Set","refId":"dart.core/Set","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"toSet0()","name":"toSet","kind":"method","line":"161"},{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"min1()","name":"min","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"isOptional":true,"id":"compare","name":"compare","children":[{"returnType":{"name":"int","refId":"dart.core/int"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"a","name":"a","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"param","line":"192"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"b","name":"b","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"param","line":"192"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param","line":"192"}],"kind":"method","comment":"\nFind the least element in the iterable.\n\nReturns null if the iterable is empty.\nOtherwise returns an element [:x:] of this [Iterable] so that\n[:x:] is not greater than [:y:] (that is, [:compare(x, y) <= 0:]) for all\nother elements [:y:] in the iterable.\n\nThe [compare] function must be a proper [Comparator<T>]. If a function is\nnot provided, [compare] defaults to [Comparable.compare].\n\n*Deprecated*. Use [reduce] with a binary min method if needed.\n","line":"191"},{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"max1()","name":"max","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"isOptional":true,"id":"compare","name":"compare","children":[{"returnType":{"name":"int","refId":"dart.core/int"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"a","name":"a","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"param","line":"218"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"b","name":"b","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"param","line":"218"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param","line":"218"}],"kind":"method","comment":"\nFind the largest element in the iterable.\n\nReturns null if the iterable is empty.\nOtherwise returns an element [:x:] of this [Iterable] so that\n[:x:] is not smaller than [:y:] (that is, [:compare(x, y) >= 0:]) for all\nother elements [:y:] in the iterable.\n\nThe [compare] function must be a proper [Comparator<T>]. If a function is\nnot provided, [compare] defaults to [Comparable.compare].\n\n*Deprecated*. Use [reduce] with a binary max method if needed.\n","line":"217"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"take1()","name":"take","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"n","name":"n","kind":"param"}],"kind":"method","comment":"\nReturns an [Iterable] with at most [n] elements.\n\nThe returned [Iterable] may contain fewer than [n] elements, if [this]\ncontains fewer than [n] elements.\n","line":"241"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"takeWhile1()","name":"takeWhile","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"test","name":"test","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"value","name":"value","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"param","line":"254"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns an [Iterable] that stops once [test] is not satisfied anymore.\n\nThe filtering happens lazily. Every new [Iterator] of the returned\n[Iterable] will start iterating over the elements of [this].\nWhen the iterator encounters an element [:e:] that does not satisfy [test],\nit discards [:e:] and moves into the finished state. That is, it will not\nask or provide any more elements.\n","line":"254"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"skip1()","name":"skip","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"n","name":"n","kind":"param"}],"kind":"method","comment":"\nReturns an [Iterable] that skips the first [n] elements.\n\nIf [this] has fewer than [n] elements, then the resulting [Iterable] will\nbe empty.\n","line":"264"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"skipWhile1()","name":"skipWhile","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"test","name":"test","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"value","name":"value","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"param","line":"277"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns an [Iterable] that skips elements while [test] is satisfied.\n\nThe filtering happens lazily. Every new [Iterator] of the returned\n[Iterable] will iterate over all elements of [this].\nAs long as the iterator's elements do not satisfy [test] they are\ndiscarded. Once an element satisfies the [test] the iterator stops testing\nand uses every element unconditionally.\n","line":"277"},{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"firstWhere2()","name":"firstWhere","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"test","name":"test","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"value","name":"value","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"param","line":"332"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"isNamed":true,"isOptional":true,"id":"orElse","name":"orElse","children":[{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"Function","name":"Function","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns the first element that satisfies the given predicate [f].\n\nIf none matches, the result of invoking the [orElse] function is\nreturned. By default, when [orElse] is `null`, a [StateError] is\nthrown.\n","line":"332"},{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"lastWhere2()","name":"lastWhere","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"test","name":"test","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"value","name":"value","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"param","line":"348"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"isNamed":true,"isOptional":true,"id":"orElse","name":"orElse","children":[{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"Function","name":"Function","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns the last element that satisfies the given predicate [f].\n\nIf none matches, the result of invoking the [orElse] function is\nreturned. By default, when [orElse] is [:null:], a [StateError] is\nthrown.\n","line":"348"},{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"singleWhere1()","name":"singleWhere","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"test","name":"test","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"value","name":"value","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"param","line":"367"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns the single element that satisfies [f]. If no or more than one\nelement match then a [StateError] is thrown.\n","line":"367"},{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"elementAt1()","name":"elementAt","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"index","name":"index","kind":"param"}],"kind":"method","comment":"\nReturns the [index]th element.\n\nIf [this] [Iterable] has fewer than [index] elements throws a\n[RangeError].\n\nNote: if [this] does not have a deterministic iteration order then the\nfunction may simply return any element without any iteration if there are\nat least [index] elements in [this].\n","line":"394"},{"ref":{"name":"Iterator","refId":"dart.core/Iterator","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"iterator","name":"iterator","kind":"property","comment":"\nReturns an [Iterator] that iterates over this [Iterable] object.\n","line":"39"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"length","name":"length","kind":"property","comment":"\nReturns the number of elements in [this].\n\nCounting all elements may be involve running through all elements and can\ntherefore be slow.\n","line":"169"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"isEmpty","name":"isEmpty","kind":"property","comment":"\nReturns true if there is no element in this collection.\n","line":"233"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"first","name":"first","kind":"property","comment":"\nReturns the first element.\n\nIf [this] is empty throws a [StateError]. Otherwise this method is\nequivalent to [:this.elementAt(0):]\n","line":"287"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"last","name":"last","kind":"property","comment":"\nReturns the last element.\n\nIf [this] is empty throws a [StateError].\n","line":"300"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"single","name":"single","kind":"property","comment":"\nReturns the single element in [this].\n\nIf [this] is empty or has more than one element throws a [StateError].\n","line":"317"},{"id":"Iterable0()","name":"Iterable","kind":"constructor","line":"20"},{"id":"Iterable.generate2()","name":"Iterable.generate","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"count","name":"count","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"generator","name":"generator","children":[{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"Function","name":"Function","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"index","name":"index","uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"param","line":"32"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"constructor","comment":"\nCreate an [Iterable] that generates its elements dynamically.\n\nThe [Iterators] created by the [Iterable] will count from\nzero to [:count - 1:] while iterating, and call [generator]\nwith that index to create the next value.\n\nAs an [Iterable], [:new Iterable.generate(n, generator)):] is equivalent to\n[:const [0, ..., n - 1].map(generator):]\n","line":"32"},{"id":"E","name":"E","kind":"typeparam"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/iterable.dart","kind":"class","comment":"\nThe [Iterable] interface allows to get an [Iterator] out of an\n[Iterable] object.\n\nThis interface is used by the for-in construct to iterate over an\n[Iterable] object.\nThe for-in construct takes an [Iterable] object at the right-hand\nside, and calls its [iterator] method to get an [Iterator] on it.\n\nA user-defined class that implements the [Iterable] interface can\nbe used as the right-hand side of a for-in construct.\n","line":"19"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/core.dart","kind":"library","line":"5"},{"id":"petitparser","name":"package:petitparser/petitparser.dart","children":[{"interfaces":[{"name":"SetableParser","refId":"petitparser/SetableParser"}],"superclass":{"name":"_DelegateParser","refId":"petitparser/_DelegateParser"},"id":"_SetableParser","name":"_SetableParser","children":[{"returnType":{"name":"void","refId":"void"},"id":"set1()","name":"set","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"parser","name":"parser","kind":"param"}],"kind":"method","line":"60"},{"id":"_SetableParser1()","name":"_SetableParser","children":[{"id":"parser","name":"parser","kind":"param"}],"kind":"constructor","line":"59"}],"uri":"package:petitparser/src/core/parsers.dart","kind":"class","isPrivate":true,"line":"58"},{"interfaces":[{"name":"Parser","refId":"petitparser/Parser"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"id":"SetableParser","name":"SetableParser","children":[{"returnType":{"name":"void","refId":"void"},"id":"set1()","name":"set","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"parser","name":"parser","kind":"param"}],"kind":"method","comment":"Sets the receiver to delegate to [parser]. ","line":"54"}],"uri":"package:petitparser/src/core/parsers.dart","kind":"class","comment":"\nInterface of a parser that can be redefined using [SetableParser#set].\n","line":"51"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"id":"Parser","name":"Parser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","comment":"\nPrivate abstract method doing the actual parsing.\n\nThe methods takes a parse [context] and returns the resulting context,\nwhich is either a [Success] or [Failure] context.\n","isPrivate":true,"line":"16"},{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"parse1()","name":"parse","children":[{"id":"input","name":"input","kind":"param"}],"kind":"method","comment":"\nReturns the parse result of the [input].\n\nThe implementation creates a default parse context on the input and calls\nthe internal parsing logic of the receiving parser.\n\nFor example, [:letter().plus().parse('abc'):] results in an instance of\n[Success], where [Result#position] is [:3:] and [Success.result] is\n[:[a, b, c]:].\n\nSimilarly, [:letter().plus().parse('123'):] results in an instance of\n[Failure], where [Result#position] is [:0:] and [Failure.message] is\n['letter expected'].\n","line":"32"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"accept1()","name":"accept","children":[{"id":"input","name":"input","kind":"param"}],"kind":"method","comment":"\nTests if the [input] can be successfully parsed.\n\nFor example, [:letter().plus().accept('abc'):] returns [:true:], and\n[:letter().plus().accept('123'):] returns [:false:].\n","line":"42"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"matches1()","name":"matches","children":[{"id":"input","name":"input","kind":"param"}],"kind":"method","comment":"\nReturns a list of all successful overlapping parses of the [input].\n\nFor example, [:letter().plus().matches('abc de'):] results in the list\n[:[['a', 'b', 'c'], ['b', 'c'], ['c'], ['d', 'e'], ['e']]:]. See\n[Parser.matchesSkipping] to retrieve non-overlapping parse results.\n","line":"53"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"matchesSkipping1()","name":"matchesSkipping","children":[{"id":"input","name":"input","kind":"param"}],"kind":"method","comment":"\nReturns a list of all successful non-overlapping parses of the input.\n\nFor example, [:letter().plus().matchesSkipping('abc de'):] results in the\nlist [:[['a', 'b', 'c'], ['d', 'e']]:]. See [Parser.matches] to retrieve\noverlapping parse results.\n","line":"66"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"optional1()","name":"optional","children":[{"isOptional":true,"id":"otherwise","name":"otherwise","kind":"param"}],"kind":"method","comment":"\nReturns new parser that accepts the receiver, if possible. The resulting\nparser returns the result of the receiver, or [:null:] if not applicable.\nThe returned value can be provided as an optional argument [otherwise].\n\nFor example, the parser [:letter().optional():] accepts a letter as input\nand returns that letter. When given something else the parser succeeds as\nwell, does not consume anything and returns [:null:].\n","line":"81"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"star0()","name":"star","kind":"method","comment":"\nReturns a parser that accepts the receiver zero or more times. The\nresulting parser returns a list of the parse results of the receiver.\n\nThis is a greedy and blind implementation that tries to consume as much\ninput as possible and that does not consider what comes afterwards.\n\nFor example, the parser [:letter().star():] accepts the empty string or\nany sequence of letters and returns a possibly empty list of the parsed\nletters.\n","line":"94"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"plus0()","name":"plus","kind":"method","comment":"\nReturns a parser that accepts the receiver one or more times. The\nresulting parser returns a list of the parse results of the receiver.\n\nThis is a greedy and blind implementation that tries to consume as much\ninput as possible and that does not consider what comes afterwards.\n\nFor example, the parser [:letter().plus():] accepts any sequence of\nletters and returns a list of the parsed letters.\n","line":"106"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"times1()","name":"times","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"count","name":"count","kind":"param"}],"kind":"method","comment":"\nReturns a parser that accepts the receiver exactly [count] times. The\nresulting parser returns a list of the parse results of the receiver.\n\nFor example, the parser [:letter().times(2):] accepts two letters and\nreturns a list of the two parsed letters.\n","line":"115"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"repeat2()","name":"repeat","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"min","name":"min","kind":"param"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"max","name":"max","kind":"param"}],"kind":"method","comment":"\nReturns a parser that accepts the receiver between [min] and [max] times.\nThe resulting parser returns a list of the parse results of the receiver.\n\nThis is a greedy and blind implementation that tries to consume as much\ninput as possible and that does not consider what comes afterwards.\n\nFor example, the parser [:letter().repeat(2, 4):] accepts a sequence of\ntwo, three, or four letters and returns the accepted letters as a list.\n","line":"127"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"seq1()","name":"seq","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"other","name":"other","kind":"param"}],"kind":"method","comment":"\nReturns a parser that accepts the receiver followed by [other]. The\nresulting parser returns a list of the parse result of the receiver\nfollowed by the parse result of [other]. Calling [SequenceParser#seq]\ncauses the sequences to be concatenated instead of nested.\n\nFor example, the parser [:letter().seq(digit()).seq(letter()):] accepts a\nletter followed by a digit and another letter. The parse result of the\ninput string [:'a1b':] is the list [:['a', '1', 'b']:].\n","line":"139"},{"isOperator":true,"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"&1()","name":"&","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"other","name":"other","kind":"param"}],"kind":"method","comment":"\nConvenience operator returning a parser accepts the receiver followed\nby [other]. See [Parser#seq] for details.\n","line":"145"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"or1()","name":"or","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"other","name":"other","kind":"param"}],"kind":"method","comment":"\nReturns a parser that accepts the receiver or [other]. The resulting\nparser returns the parse result of the receiver, if the receiver fails\nit returns the parse result of [other] (exclusive ordered choice).\n\nFor example, the parser [:letter().or(digit()):] accepts a letter or a\ndigit. An example where the order matters is the following choice between\noverlapping parsers: [:letter().or(char('a')):]. In the example the parser\n[:char('a'):] will never be activated, because the input is always consumed\n[:letter():]. This can be problematic if the author intended to attach a\nproduction action to [:char('a'):].\n","line":"159"},{"isOperator":true,"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"|1()","name":"|","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"other","name":"other","kind":"param"}],"kind":"method","comment":"\nConvenience operator returning a parser accepts the receiver or\n[other]. See [Parser#or] for details.\n","line":"165"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"and0()","name":"and","kind":"method","comment":"\nReturns a parser (logical and-predicate) that succeeds whenever the\nreceiver does, but never consumes input.\n\nFor example, the parser [:char('_').and().seq(identifier):] accepts\nidentifiers that start with an underscore character. Since the predicate\ndoes not consume accepted input, the parser [:identifier:] is given the\nability to process the complete identifier.\n","line":"176"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"not1()","name":"not","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"message","name":"message","kind":"param"}],"kind":"method","comment":"\nReturns a parser (logical not-predicate) that succeeds whenever the\nreceiver fails, but never consumes input.\n\nFor example, the parser [:char('_').not().seq(identifier):] accepts\nidentifiers that do not start with an underscore character. If the parser\n[:char('_'):] accepts the input, the negation and subsequently the\ncomplete parser fails. Otherwise the parser [:identifier:] is given the\nability to process the complete identifier.\n","line":"188"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"neg1()","name":"neg","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"message","name":"message","kind":"param"}],"kind":"method","comment":"\nReturns a parser that consumes any input token (character), but the\nreceiver.\n\nFor example, the parser [:letter().neg():] accepts any input but a letter.\nThe parser fails for inputs like [:'a':] or [:'Z':], but succeeds for\ninput like [:'1':], [:'_':] or [:'$':].\n","line":"198"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"flatten0()","name":"flatten","kind":"method","comment":"\nReturns a parser that discards the result of the receiver, and returns\na sub-string of the consumed elements in the string/list being parsed.\n\nFor example, the parser [:letter().plus().flatten():] returns [:'abc':]\nfor the input [:'abc':]. In contrast, the parser [:letter().plus():] would\nreturn [:['a', 'b', 'c']:] for the same input instead.\n","line":"208"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"token0()","name":"token","kind":"method","comment":"\nReturns a parser that discards the result of the receiver and returns\na [Token]. The token carries information about where the token started and\nstopped in the input stream.\n\nFor example, the parser [:letter().plus().token():] returns the token\n[:Token[start: 0, stop: 3, value: abc]:] for the input [:'abc':].\n","line":"218"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"trim1()","name":"trim","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"isOptional":true,"id":"trimmer","name":"trimmer","kind":"param"}],"kind":"method","comment":"\nReturns a parser that consumes input before and after the receiver. The\noptional argument [trimmer] is a parser that consumes the excess input. By\ndefault [:whitespace():] is used.\n\nFor example, the parser [:letter().plus().trim():] returns [:['a', 'b']:]\nfor the input [:' ab\\n':] and consumes the complete input string.\n","line":"228"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"end1()","name":"end","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"defaultValue":"'end of input expected'","isOptional":true,"id":"message","name":"message","kind":"param"}],"kind":"method","comment":"\nReturns a parser that succeeds only if the receiver consumes the complete\ninput, otherwise return a failure with the optional [message].\n\nFor example, the parser [:letter().end():] succeeds on the input [:'a':]\nand fails on [:'ab':]. In contrast the parser [:letter():] alone would\nsucceed on both inputs, but not consume everything for the second input.\n","line":"240"},{"returnType":{"name":"SetableParser","refId":"petitparser/SetableParser"},"id":"setable0()","name":"setable","kind":"method","comment":"\nReturns a parser that points to the receiver, but can be changed to point\nto something else at a later point in time.\n\nFor example, the parser [:letter().setable():] behaves exactly the same\nas [:letter():], but it can be replaced with another parser using\n[SetableParser#set].\n","line":"252"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"map1()","name":"map","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"function","name":"function","kind":"param"}],"kind":"method","comment":"\nReturns a parser that evaluates [function] as action handler on success\nof the receiver.\n\nFor example, the parser [:digit().map((char) => int.parse(char)):] returns\nthe number [:1:] for the input string [:'1':].\n","line":"261"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"pick1()","name":"pick","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"index","name":"index","kind":"param"}],"kind":"method","comment":"\nReturns a parser that transform a successful parse result by returning\nthe element at [index] of a list. A negative index can be used to access\nthe elements from the back of the list.\n\nFor example, the parser [:letter().star().pick(-1):] returns the last\nletter parsed. For the input [:'abc':] it returns [:'c':].\n","line":"271"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"permute1()","name":"permute","children":[{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"int","refId":"dart.core/int"}]},"id":"indexes","name":"indexes","kind":"param"}],"kind":"method","comment":"\nReturns a parser that transforms a successful parse result by returning\nthe permuted elements at [indexes] of a list. Negative indexes can be\nused to access the elements from the back of the list.\n\nFor example, the parser [:letter().star().permute([0, -1]):] returns the\nfirst and last letter parsed. For the input [:'abc':] it returns\n[:['a', 'c']:].\n","line":"286"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"separatedBy3()","name":"separatedBy","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"separator","name":"separator","kind":"param"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isNamed":true,"defaultValue":"true","isOptional":true,"id":"includeSeparators","name":"includeSeparators","kind":"param"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isNamed":true,"defaultValue":"false","isOptional":true,"id":"optionalSeparatorAtEnd","name":"optionalSeparatorAtEnd","kind":"param","line":"310"}],"kind":"method","comment":"\nReturns a parser that consumes the receiver one or more times separated\nby the [separator] parser. The resulting parser returns a flat list of\nthe parse results of the receiver interleaved with the parse result of the\nseparator parser.\n\nIf the optional argument [includeSeparators] is set to [:false:], then the\nseparators are not included in the parse result. If the optional argument\n[optionalSeparatorAtEnd] is set to [:true:] the parser also accepts an\noptional separator at the end.\n\nFor example, the parser [:digit().separatedBy(char('-')):] returns a parser\nthat consumes input like [:'1-2-3':] and returns a list of the elements and\nseparators: [:['1', '-', '2', '-', '3']:].\n","line":"309"},{"returnType":{"name":"void","refId":"void"},"id":"replace2()","name":"replace","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"source","name":"source","kind":"param"},{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"target","name":"target","kind":"param"}],"kind":"method","comment":"\nChanges the receiver by replacing [source] with [target]. Does nothing\nif [source] does not exist in [Parser#children].\n\nThe following example creates a letter parser and then defines a parser\ncalled [:example:] that accepts one or more letters. Eventually the parser\n[:example:] is modified by replacing the [:letter:] parser with a new\nparser that accepts a digit. The resulting [:example:] parser accepts one\nor more digits.\n\n    var letter = letter();\n    var example = letter.plus();\n    example.replace(letter, digit());\n","line":"358"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"Parser","refId":"petitparser/Parser"}]},"id":"children","name":"children","kind":"property","comment":"\nReturns a list of directly referenced parsers.\n\nFor example, [:letter().children:] returns the empty collection [:[]:],\nbecause the letter parser is a primitive or leaf parser that does not\ndepend or call any other parser.\n\nIn contrast, [:letter().or(digit()).children:] returns a collection\ncontaining both the [:letter():] and [:digit():] parser.\n","line":"342"}],"uri":"package:petitparser/src/core/parser.dart","kind":"class","comment":"\nAbstract base class of all parsers.\n","line":"8"},{"superclass":{"name":"_SetableParser","refId":"petitparser/_SetableParser"},"isAbstract":true,"id":"CompositeParser","name":"CompositeParser","children":[{"returnType":{"name":"void","refId":"void"},"id":"initialize0()","name":"initialize","kind":"method","comment":"\nInitializes the composite grammar.\n","line":"33"},{"returnType":{"name":"void","refId":"void"},"id":"_complete0()","name":"_complete","kind":"method","comment":"\nInternal method to complete the grammar.\n","isPrivate":true,"line":"38"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"ref1()","name":"ref","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"}],"kind":"method","comment":"\nReturns a reference to a production with a [name].\n\nThis method works during initialization and after completion of the\ninitialization. During the initialization it returns delegate parsers\nthat are eventually replaced by the real parsers. Afterwards it\nreturns the defined parser (mostly useful for testing).\n","line":"59"},{"isOperator":true,"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"[]1()","name":"[]","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"}],"kind":"method","comment":"\nConvenience operator returning a reference to a production with\na [name]. See [CompositeParser#ref] for details.\n","line":"77"},{"returnType":{"name":"void","refId":"void"},"id":"def2()","name":"def","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"},{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"parser","name":"parser","kind":"param"}],"kind":"method","comment":"\nDefines a production with a [name] and a [parser]. Only call this method\nfrom [initialize].\n\nThe following example defines a list production that consumes\nseveral elements separated by a comma.\n\n    def('list', ref('element').separatedBy(char(',')));\n","line":"88"},{"returnType":{"name":"void","refId":"void"},"id":"redef2()","name":"redef","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"},{"id":"replacement","name":"replacement","kind":"param"}],"kind":"method","comment":"\nRedefinies an existing production with a [name] and a [replacement]\nparser or function producing a new parser. The code raises a [StateError]\nif [name] is an undefined production. Only call this method from\n[initialize].\n\nThe following example redefines the previously defined list production\nby making it optional:\n\n    redef('list', (parser) => parser.optional());\n","line":"109"},{"returnType":{"name":"void","refId":"void"},"id":"action2()","name":"action","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"function","name":"function","children":[{"id":"Function","name":"Function","children":[{"id":"Dynamic","name":"Dynamic","uri":"package:petitparser/src/core/composite.dart","kind":"param","line":"131"}],"uri":"file:///usr/local/Cellar/dart-editor/20602/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nAttaches an action [function] to an existing production [name]. The code\nraises a [StateError] if [name] is an undefined production. Only call this\nmethod from [initialize].\n\nThe following example attaches an action returning the size of list of\nthe previously defined list production:\n\n    action('list', (list) => list.length);\n\n","line":"131"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"_completed","name":"_completed","kind":"variable","isPrivate":true,"line":"21"},{"isFinal":true,"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"},{"name":"Parser","refId":"petitparser/Parser"}]},"id":"_defined","name":"_defined","kind":"variable","isPrivate":true,"line":"22"},{"isFinal":true,"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"},{"name":"SetableParser","refId":"petitparser/SetableParser"}]},"id":"_undefined","name":"_undefined","kind":"variable","isPrivate":true,"line":"23"},{"id":"CompositeParser0()","name":"CompositeParser","kind":"constructor","line":"25"}],"uri":"package:petitparser/src/core/composite.dart","kind":"class","comment":"\nHelper to compose complex grammars from various primitive parsers.\n\nTo create a new composite grammar subclass [CompositeParser]. Override\nthe method [initialize] and for every production call [def] giving the\nproduction a name. The start production must be named 'start'. To refer\nto other produtions (forward and backward) use [ref].\n\nYou might want to create future subclasses of your composite grammar\nto redefine the grammar or attach custom actions. In such a subclass\noverride the method [initialize] again and call super. Then use\n[redef] to redefine an existing production, and [action] to attach an\naction to an existing production.\n","line":"19"},{"superclass":{"name":"Parser","refId":"petitparser/Parser"},"id":"_DelegateParser","name":"_DelegateParser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","isPrivate":true,"line":"15"},{"returnType":{"name":"void","refId":"void"},"id":"replace2()","name":"replace","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"source","name":"source","kind":"param"},{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"target","name":"target","kind":"param"}],"kind":"method","line":"21"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"Parser","refId":"petitparser/Parser"}]},"id":"children","name":"children","kind":"property","line":"19"},{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"_delegate","name":"_delegate","kind":"variable","isPrivate":true,"line":"11"},{"id":"_DelegateParser1()","name":"_DelegateParser","children":[{"initializedField":{"name":"_delegate","refId":"petitparser/_DelegateParser/_delegate"},"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"_delegate","name":"_delegate","kind":"param","isPrivate":true}],"kind":"constructor","line":"13"}],"uri":"package:petitparser/src/core/combinators.dart","kind":"class","comment":"\nA parser that delegates to another one. Normally users do not need to\ndirectly use a delegate parser.\n","isPrivate":true,"line":"9"}],"uri":"package:petitparser/petitparser.dart","kind":"library","comment":"\n# Writing a Simple Grammar\n\nWriting grammars with PetitParser is simple as writing Dart code. For\nexample, to write a grammar that can parse identifiers that start with\na letter followed by zero or more letter or digits is defined as follows:\n\n    Parser id = letter().seq(letter().or(digit()).star());\n\nIf you look at the object [:id:] in the debugger, you'll notice\nthat the code above buils a tree of parser objects:\n\n- Sequence: This parser accepts a sequence of parsers.\n- - Predicate: This parser accepts a single letter.\n- - Repeater: This parser accepts zero or more times another parser.\n- - - Choice: This parser accepts a single word character.\n- - - - Predicate: This parser accepts a single letter.\n- - - - Predicate: This parser accepts a single digit.\n\n# Parsing Some Input\n\nTo actually parse a [String] (or [List]) we can use the method\n[Parser#parse]:\n\n    Result id1 = id.parse('yeah');\n    Result id2 = id.parse('f12');\n\nThe method [Parser#parse] returns a parse [Result], which is either an\ninstance of [Success] or [Failure]. In both examples above we are\nsuccessful and can retrieve the parse result using [Success.result]:\n\n    print(id1.result);                  // ['y', ['e', 'a', 'h']]\n    print(id2.result);                  // ['f', ['1', '2']]\n\nWhile it seems odd to get these nested arrays with characters as a return\nvalue, this is the default decomposition of the input into a parse tree.\nWe'll see in a while how that can be customized.\n\nIf we try to parse something invalid we get an instance of [Failure] as\nan answer and we can retrieve a descriptive error message using\n[Failure.message]:\n\n    Result id3 = id.parse('123');\n    print(id3.message);                // 'letter expected'\n    print(id3.position);               // 0\n\nTrying to retrieve the parse result by calling [Failure.result] would throw\nthe exception [UnsupportedError]. [Result.isSuccess] and [Result.isFailure]\ncan be used to decide if the parse was successful.\n\nIf you are only interested if a given string matches or not you can use the\nhelper method [Parser.accept]:\n\n    print(id.accept('foo'));            // true\n    print(id.accept('123'));            // false\n\n# Different Kinds of Parsers\n\nPetitParser provide a large set of ready-made parser that you can compose\nto consume and transform arbitrarily complex languages. The terminal parsers\nare the most simple ones. We've already seen a few of those:\n\n  * [:char('a'):] parses the character a.\n  * [:string('abc'):] parses the string =='abc'==.\n  * [:any():] parses any character.\n  * [:digit():] parses any digit from 0 to 9.\n  * [:letter():] parses any letter from a to z and A to Z.\n  * [:word():] parses any letter or digit.\n\nSo instead of using the letter and digit predicate, we could have written\nour identifier parser like this:\n\n    var id = letter().seq(word().star());\n\nThe next set of parsers are used to combine other parsers together:\n\n  * [:p1.seq(p2):] parses p1 followed by p2 (sequence).\n  * [:p1.or(p2):] parses p1, if that doesn't work parses p2 (ordered choice).\n  * [:p.star():] parses p zero or more times.\n  * [:p.plus():] parses p one or more times.\n  * [:p.optional():] parses p, if possible.\n  * [:p.and():] parses p, but does not consume its input.\n  * [:p.not():] parses p and succeed when p fails, but does not consume its input.\n  * [:p.end():] parses p and succeed at the end of the input.\n\nTo attach an action or transformation to a parser we can use the following\nmethods:\n\n  * [:p.map((value) => ...):] performs the transformation given the function.\n  * [:p.pick(n):] returns the n-th element of the list p returns.\n  * [:p.flatten():] creates a string from the result of p.\n  * [:p.token():] creates a token from the result of p.\n  * [:p.trim():] trims whitespaces before and after p.\n\nTo return a string of the parsed identifier, we can modify our parser like\nthis:\n\n    var id = letter().seq(word().star()).flatten();\n\nTo conveniently find all matches in a given input string you can use\n[Parser.matchesSkipping]:\n\n    var matches = id.matchesSkipping('foo 123 bar4');\n    print(matches);                    // ['foo', 'bar4']\n\n\nThese are the basic elements to build parsers. There are a few more well\ndocumented and tested factory methods in the [Parser] class. If you want\nbrowse their documentation and tests.\n\n# Writing a More Complicated Grammar\n\nNow we are able to write a more complicated grammar for evaluating simple\narithmetic expressions. Within a file we start with the grammar for a\nnumber (actually an integer):\n\n    var number = digit().plus().flatten().trim().map(int.parse);\n\nThen we define the productions for addition and multiplication in order of\nprecedence. Note that we instantiate the productions with undefined parsers\nupfront, because they recursively refer to each other. Later on we can\nresolve this recursion by setting their reference:\n\n    var term = undefined();\n    var prod = undefined();\n    var prim = undefined();\n\n    term.set(prod.seq(char('+').trim()).seq(term).map((values) {\n      return values[0] + values[2];\n    }).or(prod));\n    prod.set(prim.seq(char('*').trim()).seq(prod).map((values) {\n      return values[0] * values[2];\n    }).or(prim));\n    prim.set(char('(').trim().seq(term).seq(char(')'.trim())).map((values) {\n      return values[1];\n    }).or(number));\n\nTo make sure that our parser consumes all input we wrap it with the [:end():]\nparser into the start production:\n\n    var start = term.end();\n\nThat's it, now we can test our parser and evaluator:\n\n    print(start.parse('1 + 2 * 3').result);       // 7\n    print(start.parse('(1 + 2) * 3').result);     // 9\n\nAs an exercise we could extend the parser to also accept negative numbers\nand floating point numbers, not only integers. Furthermore it would be\nuseful to support subtraction and division as well. All these features\ncan be added with a few lines of PetitParser code.\n","line":"155"}],"id":"xml","children":[{"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"XmlName","name":"XmlName","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"id":"toString0()","name":"toString","kind":"method","line":"339"},{"returnType":{"name":"void","refId":"void"},"id":"writeTo1()","name":"writeTo","children":[{"ref":{"name":"StringBuffer","refId":"dart.core/StringBuffer"},"id":"buffer","name":"buffer","kind":"param"}],"kind":"method","line":"345"},{"isOperator":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"==1()","name":"==","children":[{"ref":{"name":"XmlName","refId":"xml/XmlName"},"id":"obj","name":"obj","kind":"param"}],"kind":"method","line":"353"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"local","name":"local","kind":"property","line":"335"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"prefix","name":"prefix","kind":"property","line":"336"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"qualified","name":"qualified","kind":"property","line":"337"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"id":"_prefix","name":"_prefix","kind":"variable","isPrivate":true,"line":"319"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"id":"_local","name":"_local","kind":"variable","isPrivate":true,"line":"320"},{"id":"XmlName._internal2()","name":"XmlName._internal","children":[{"initializedField":{"name":"_prefix","refId":"xml/XmlName/_prefix"},"ref":{"name":"String","refId":"dart.core/String"},"id":"_prefix","name":"_prefix","kind":"param","isPrivate":true},{"initializedField":{"name":"_local","refId":"xml/XmlName/_local"},"ref":{"name":"String","refId":"dart.core/String"},"id":"_local","name":"_local","kind":"param","isPrivate":true}],"kind":"constructor","isPrivate":true,"line":"322"},{"id":"XmlName1()","name":"XmlName","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"}],"kind":"constructor","line":"324"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/xml/nodes.dart","kind":"class","comment":"\nXML entity name.\n","line":"317"},{"superclass":{"name":"XmlParent","refId":"xml/XmlParent"},"id":"XmlElement","name":"XmlElement","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"id":"getAttribute1()","name":"getAttribute","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"key","name":"key","kind":"param"}],"kind":"method","line":"280"},{"returnType":{"name":"XmlAttribute","refId":"xml/XmlAttribute"},"id":"getAttributeNode1()","name":"getAttributeNode","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"key","name":"key","kind":"param"}],"kind":"method","line":"285"},{"returnType":{"name":"void","refId":"void"},"id":"writeTo1()","name":"writeTo","children":[{"ref":{"name":"StringBuffer","refId":"dart.core/StringBuffer"},"id":"buffer","name":"buffer","kind":"param"}],"kind":"method","line":"294"},{"ref":{"name":"XmlName","refId":"xml/XmlName"},"id":"name","name":"name","kind":"property","line":"277"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"XmlAttribute","refId":"xml/XmlAttribute"}]},"id":"attributes","name":"attributes","kind":"property","line":"278"},{"isFinal":true,"ref":{"name":"XmlName","refId":"xml/XmlName"},"id":"_name","name":"_name","kind":"variable","isPrivate":true,"line":"267"},{"isFinal":true,"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"XmlAttribute","refId":"xml/XmlAttribute"}]},"id":"_attributes","name":"_attributes","kind":"variable","isPrivate":true,"line":"268"},{"id":"XmlElement3()","name":"XmlElement","children":[{"ref":{"name":"XmlName","refId":"xml/XmlName"},"id":"name","name":"name","kind":"param"},{"ref":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"XmlAttribute","refId":"xml/XmlAttribute"}]},"id":"attributes","name":"attributes","kind":"param"},{"ref":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"XmlNode","refId":"xml/XmlNode"}]},"id":"children","name":"children","kind":"param"}],"kind":"constructor","line":"270"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/xml/nodes.dart","kind":"class","comment":"\nXML element node.\n","line":"265"},{"superclass":{"name":"XmlParent","refId":"xml/XmlParent"},"id":"XmlDocument","name":"XmlDocument","children":[{"ref":{"name":"XmlDocument","refId":"xml/XmlDocument"},"id":"document","name":"document","kind":"property","line":"249"},{"ref":{"name":"XmlElement","refId":"xml/XmlElement"},"id":"rootElement","name":"rootElement","kind":"property","line":"251"},{"id":"XmlDocument1()","name":"XmlDocument","children":[{"ref":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"XmlNode","refId":"xml/XmlNode"}]},"id":"children","name":"children","kind":"param"}],"kind":"constructor","line":"247"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/xml/nodes.dart","kind":"class","comment":"\nXML document node.\n","line":"245"},{"superclass":{"name":"XmlNode","refId":"xml/XmlNode"},"isAbstract":true,"id":"XmlParent","name":"XmlParent","children":[{"returnType":{"name":"void","refId":"void"},"id":"writeTo1()","name":"writeTo","children":[{"ref":{"name":"StringBuffer","refId":"dart.core/StringBuffer"},"id":"buffer","name":"buffer","kind":"param"}],"kind":"method","line":"234"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"XmlNode","refId":"xml/XmlNode"}]},"id":"children","name":"children","kind":"property","line":"232"},{"isFinal":true,"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"XmlNode","refId":"xml/XmlNode"}]},"id":"_children","name":"_children","kind":"variable","isPrivate":true,"line":"223"},{"id":"XmlParent1()","name":"XmlParent","children":[{"ref":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"XmlNode","refId":"xml/XmlNode"}]},"id":"children","name":"children","kind":"param"}],"kind":"constructor","line":"225"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/xml/nodes.dart","kind":"class","comment":"\nAbstract XML node with actual children.\n","line":"221"},{"superclass":{"name":"XmlData","refId":"xml/XmlData"},"id":"XmlText","name":"XmlText","children":[{"returnType":{"name":"void","refId":"void"},"id":"writeTo1()","name":"writeTo","children":[{"ref":{"name":"StringBuffer","refId":"dart.core/StringBuffer"},"id":"buffer","name":"buffer","kind":"param"}],"kind":"method","line":"212"},{"id":"XmlText1()","name":"XmlText","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"data","name":"data","kind":"param"}],"kind":"constructor","line":"210"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/xml/nodes.dart","kind":"class","comment":"\nXML text node.\n","line":"208"},{"superclass":{"name":"XmlData","refId":"xml/XmlData"},"id":"XmlProcessing","name":"XmlProcessing","children":[{"returnType":{"name":"void","refId":"void"},"id":"writeTo1()","name":"writeTo","children":[{"ref":{"name":"StringBuffer","refId":"dart.core/StringBuffer"},"id":"buffer","name":"buffer","kind":"param"}],"kind":"method","line":"196"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"target","name":"target","kind":"property","line":"194"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"id":"_target","name":"_target","kind":"variable","isPrivate":true,"line":"190"},{"id":"XmlProcessing2()","name":"XmlProcessing","children":[{"initializedField":{"name":"_target","refId":"xml/XmlProcessing/_target"},"ref":{"name":"String","refId":"dart.core/String"},"id":"_target","name":"_target","kind":"param","isPrivate":true},{"ref":{"name":"String","refId":"dart.core/String"},"id":"data","name":"data","kind":"param"}],"kind":"constructor","line":"192"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/xml/nodes.dart","kind":"class","comment":"\nXML processing instruction.\n","line":"188"},{"superclass":{"name":"XmlData","refId":"xml/XmlData"},"id":"XmlDoctype","name":"XmlDoctype","children":[{"returnType":{"name":"void","refId":"void"},"id":"writeTo1()","name":"writeTo","children":[{"ref":{"name":"StringBuffer","refId":"dart.core/StringBuffer"},"id":"buffer","name":"buffer","kind":"param"}],"kind":"method","line":"177"},{"id":"XmlDoctype1()","name":"XmlDoctype","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"data","name":"data","kind":"param"}],"kind":"constructor","line":"175"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/xml/nodes.dart","kind":"class","comment":"\nXML doctype node.\n","line":"173"},{"superclass":{"name":"XmlData","refId":"xml/XmlData"},"id":"XmlComment","name":"XmlComment","children":[{"returnType":{"name":"void","refId":"void"},"id":"writeTo1()","name":"writeTo","children":[{"ref":{"name":"StringBuffer","refId":"dart.core/StringBuffer"},"id":"buffer","name":"buffer","kind":"param"}],"kind":"method","line":"162"},{"id":"XmlComment1()","name":"XmlComment","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"data","name":"data","kind":"param"}],"kind":"constructor","line":"160"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/xml/nodes.dart","kind":"class","comment":"\nXML comment node.\n","line":"158"},{"superclass":{"name":"XmlNode","refId":"xml/XmlNode"},"isAbstract":true,"id":"XmlData","name":"XmlData","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"data","name":"data","kind":"property","line":"151"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"id":"_data","name":"_data","kind":"variable","isPrivate":true,"line":"147"},{"id":"XmlData1()","name":"XmlData","children":[{"initializedField":{"name":"_data","refId":"xml/XmlData/_data"},"ref":{"name":"String","refId":"dart.core/String"},"id":"_data","name":"_data","kind":"param","isPrivate":true}],"kind":"constructor","line":"149"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/xml/nodes.dart","kind":"class","comment":"\nAbstract XML data node.\n","line":"145"},{"superclass":{"name":"XmlNode","refId":"xml/XmlNode"},"id":"XmlAttribute","name":"XmlAttribute","children":[{"returnType":{"name":"void","refId":"void"},"id":"writeTo1()","name":"writeTo","children":[{"ref":{"name":"StringBuffer","refId":"dart.core/StringBuffer"},"id":"buffer","name":"buffer","kind":"param"}],"kind":"method","line":"133"},{"ref":{"name":"XmlName","refId":"xml/XmlName"},"id":"name","name":"name","kind":"property","line":"130"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"value","name":"value","kind":"property","line":"131"},{"isFinal":true,"ref":{"name":"XmlName","refId":"xml/XmlName"},"id":"_name","name":"_name","kind":"variable","isPrivate":true,"line":"125"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"id":"_value","name":"_value","kind":"variable","isPrivate":true,"line":"126"},{"id":"XmlAttribute2()","name":"XmlAttribute","children":[{"initializedField":{"name":"_name","refId":"xml/XmlAttribute/_name"},"ref":{"name":"XmlName","refId":"xml/XmlName"},"id":"_name","name":"_name","kind":"param","isPrivate":true},{"initializedField":{"name":"_value","refId":"xml/XmlAttribute/_value"},"ref":{"name":"String","refId":"dart.core/String"},"id":"_value","name":"_value","kind":"param","isPrivate":true}],"kind":"constructor","line":"128"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/xml/nodes.dart","kind":"class","comment":"\nXML attribute node.\n","line":"123"},{"superclass":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"XmlNode","refId":"xml/XmlNode"}]},"isAbstract":true,"id":"XmlNode","name":"XmlNode","children":[{"returnType":{"name":"void","refId":"void"},"id":"_allAllNodesTo1()","name":"_allAllNodesTo","children":[{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"XmlNode","refId":"xml/XmlNode"}]},"id":"nodes","name":"nodes","kind":"param"}],"kind":"method","isPrivate":true,"line":"36"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"toString0()","name":"toString","kind":"method","comment":"\nAnswer a print string of the receiver.\n","line":"107"},{"returnType":{"name":"void","refId":"void"},"id":"writeTo1()","name":"writeTo","children":[{"ref":{"name":"StringBuffer","refId":"dart.core/StringBuffer"},"id":"buffer","name":"buffer","kind":"param"}],"kind":"method","comment":"\nWrites the XML string of the receiver to a {@code buffer}.\n","line":"116"},{"ref":{"name":"XmlNode","refId":"xml/XmlNode"},"id":"parent","name":"parent","kind":"property","comment":"\nAnswer the parent node of the receiver, or [null] if there is none.\n","line":"15"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"XmlAttribute","refId":"xml/XmlAttribute"}]},"id":"attributes","name":"attributes","kind":"property","comment":"\nAnswer the attribute nodes of the receiver.\n","line":"20"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"XmlNode","refId":"xml/XmlNode"}]},"id":"children","name":"children","kind":"property","comment":"\nAnswer the child nodes of the receiver.\n","line":"25"},{"ref":{"name":"Iterator","refId":"dart.core/Iterator","arguments":[{"name":"XmlNode","refId":"xml/XmlNode"}]},"id":"iterator","name":"iterator","kind":"property","comment":"\nAnswer an iterator over the receiver, all attributes and nested children.\n","line":"30"},{"ref":{"name":"XmlNode","refId":"xml/XmlNode"},"id":"root","name":"root","kind":"property","comment":"\nAnswer the root of the subtree in which this node is found, whether that's\na document or another element.\n","line":"48"},{"ref":{"name":"XmlDocument","refId":"xml/XmlDocument"},"id":"document","name":"document","kind":"property","comment":"\nAnswer the document that contains this node, or [null] if the node is\nnot part of a document.\n","line":"56"},{"ref":{"name":"XmlNode","refId":"xml/XmlNode"},"id":"firstChild","name":"firstChild","kind":"property","comment":"\nAnswer the first child of the receiver or [null].\n","line":"63"},{"ref":{"name":"XmlNode","refId":"xml/XmlNode"},"id":"lastChild","name":"lastChild","kind":"property","comment":"\nAnswer the last child of the receiver or [null].\n","line":"70"},{"ref":{"name":"XmlNode","refId":"xml/XmlNode"},"id":"nextSibling","name":"nextSibling","kind":"property","comment":"\nAnswer the next sibling of the receiver or [null].\n","line":"77"},{"ref":{"name":"XmlNode","refId":"xml/XmlNode"},"id":"previousSibling","name":"previousSibling","kind":"property","comment":"\nAnswer the previous sibling of the receiver or [null].\n","line":"92"},{"ref":{"name":"XmlNode","refId":"xml/XmlNode"},"id":"_parent","name":"_parent","kind":"variable","isPrivate":true,"line":"10"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/xml/nodes.dart","kind":"class","comment":"\nAbstract XML node.\n","line":"8"},{"superclass":{"name":"XmlGrammar","refId":"xml/XmlGrammar"},"id":"XmlParser","name":"XmlParser","children":[{"returnType":{"name":"void","refId":"void"},"id":"initialize0()","name":"initialize","kind":"method","line":"10"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/xml/parser.dart","kind":"class","comment":"\nXML parser definition.\n","line":"8"},{"superclass":{"name":"CompositeParser","refId":"petitparser/CompositeParser"},"id":"XmlGrammar","name":"XmlGrammar","children":[{"returnType":{"name":"void","refId":"void"},"id":"initialize0()","name":"initialize","kind":"method","line":"15"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"NAME_START_CHARS","name":"NAME_START_CHARS","kind":"variable","line":"10"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"isStatic":true,"id":"NAME_CHARS","name":"NAME_CHARS","kind":"variable","line":"13"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/xml/grammar.dart","kind":"class","comment":"\nXML grammar definition.\n","line":"8"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/xml.dart","kind":"library","line":"3"}