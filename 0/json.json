{"dependencies":[{"id":"dart.core","name":"dart:core","children":[{"id":"Object","name":"Object","children":[{"isOperator":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"==1()","name":"==","children":[{"id":"other","name":"other","kind":"param"}],"kind":"method","comment":"\nThe equality operator.\n\nThe default behavior for all [Object]s is to return true if and\nonly if [:this:] and [other] are the same object.\n\nIf a subclass overrides the equality operator it should override\nthe [hashCode] method as well to maintain consistency.\n","line":"29"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"toString0()","name":"toString","kind":"method","comment":"\nReturns a string representation of this object.\n","line":"48"},{"id":"noSuchMethod1()","name":"noSuchMethod","children":[{"ref":{"name":"InvocationMirror","refId":"dart.core/InvocationMirror"},"id":"invocation","name":"invocation","kind":"param"}],"kind":"method","comment":"\n[noSuchMethod] is invoked when users invoke a non-existant method\non an object. The name of the method and the arguments of the\ninvocation are passed to [noSuchMethod] in an [InvocationMirror].\nIf [noSuchMethod] returns a value, that value becomes the result of\nthe original invocation.\n\nThe default behavior of [noSuchMethod] is to throw a\n[noSuchMethodError].\n","line":"60"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"hashCode","name":"hashCode","kind":"property","comment":"\nGet a hash code for this object.\n\nAll objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator [:==:]. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.\n\nIf a subclass overrides [hashCode] it should override the\nequality operator as well to maintain consistency.\n","line":"43"},{"ref":{"name":"Type","refId":"dart.core/Type"},"id":"runtimeType","name":"runtimeType","kind":"property","comment":"\nA representation of the runtime type of the object.\n","line":"65"},{"id":"Object0()","name":"Object","kind":"constructor","comment":"\nCreates a new [Object] instance.\n\n[Object] instances have no meaningful state, and are only useful\nthrough their identity. An [Object] instance is equal to itself\nonly.\n","line":"18"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/object.dart","kind":"class","comment":"\nEverything in Dart is an [Object].\n","line":"10"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/core.dart","kind":"library","line":"5"},{"id":"petitparser","name":"package:petitparser/petitparser.dart","children":[{"interfaces":[{"name":"SetableParser","refId":"petitparser/SetableParser"}],"superclass":{"name":"_DelegateParser","refId":"petitparser/_DelegateParser"},"id":"_SetableParser","name":"_SetableParser","children":[{"returnType":{"name":"void","refId":"void"},"id":"set1()","name":"set","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"parser","name":"parser","kind":"param"}],"kind":"method","line":"60"},{"id":"_SetableParser1()","name":"_SetableParser","children":[{"id":"parser","name":"parser","kind":"param"}],"kind":"constructor","line":"59"}],"uri":"package:petitparser/src/core/parsers.dart","kind":"class","isPrivate":true,"line":"58"},{"interfaces":[{"name":"Parser","refId":"petitparser/Parser"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"id":"SetableParser","name":"SetableParser","children":[{"returnType":{"name":"void","refId":"void"},"id":"set1()","name":"set","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"parser","name":"parser","kind":"param"}],"kind":"method","comment":"Sets the receiver to delegate to [parser]. ","line":"54"}],"uri":"package:petitparser/src/core/parsers.dart","kind":"class","comment":"\nInterface of a parser that can be redefined using [SetableParser.set].\n","line":"51"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"id":"Parser","name":"Parser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","comment":"\nPrivate abstract method doing the actual parsing.\n\nThe methods takes a parse [context] and returns the resulting context,\nwhich is either a [Success] or [Failure] context.\n","isPrivate":true,"line":"16"},{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"parse1()","name":"parse","children":[{"id":"input","name":"input","kind":"param"}],"kind":"method","comment":"\nReturns the parse result of the [input].\n\nThe implementation creates a default parse context on the input and calls\nthe internal parsing logic of the receiving parser.\n\nFor example, [:letter().plus().parse('abc'):] results in an instance of\n[Success], where [Result.position] is [:3:] and [Success.result] is\n[:[a, b, c]:].\n\nSimilarly, [:letter().plus().parse('123'):] results in an instance of\n[Failure], where [Result.position] is [:0:] and [Failure.message] is\n['letter expected'].\n","line":"32"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"accept1()","name":"accept","children":[{"id":"input","name":"input","kind":"param"}],"kind":"method","comment":"\nTests if the [input] can be successfully parsed.\n\nFor example, [:letter().plus().accept('abc'):] returns [:true:], and\n[:letter().plus().accept('123'):] returns [:false:].\n","line":"42"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"matches1()","name":"matches","children":[{"id":"input","name":"input","kind":"param"}],"kind":"method","comment":"\nReturns a list of all successful overlapping parses of the [input].\n\nFor example, [:letter().plus().matches('abc de'):] results in the list\n[:[['a', 'b', 'c'], ['b', 'c'], ['c'], ['d', 'e'], ['e']]:]. See\n[Parser.matchesSkipping] to retrieve non-overlapping parse results.\n","line":"53"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"matchesSkipping1()","name":"matchesSkipping","children":[{"id":"input","name":"input","kind":"param"}],"kind":"method","comment":"\nReturns a list of all successful non-overlapping parses of the input.\n\nFor example, [:letter().plus().matchesSkipping('abc de'):] results in the\nlist [:[['a', 'b', 'c'], ['d', 'e']]:]. See [Parser.matches] to retrieve\noverlapping parse results.\n","line":"66"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"optional1()","name":"optional","children":[{"isOptional":true,"id":"otherwise","name":"otherwise","kind":"param"}],"kind":"method","comment":"\nReturns new parser that accepts the receiver, if possible. The resulting\nparser returns the result of the receiver, or [:null:] if not applicable.\nThe returned value can be provided as an optional argument [otherwise].\n\nFor example, the parser [:letter().optional():] accepts a letter as input\nand returns that letter. When given something else the parser succeeds as\nwell, does not consume anything and returns [:null:].\n","line":"81"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"star0()","name":"star","kind":"method","comment":"\nReturns a parser that accepts the receiver zero or more times. The\nresulting parser returns a list of the parse results of the receiver.\n\nThis is a greedy and blind implementation that tries to consume as much\ninput as possible and that does not consider what comes afterwards.\n\nFor example, the parser [:letter().star():] accepts the empty string or\nany sequence of letters and returns a possibly empty list of the parsed\nletters.\n","line":"94"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"plus0()","name":"plus","kind":"method","comment":"\nReturns a parser that accepts the receiver one or more times. The\nresulting parser returns a list of the parse results of the receiver.\n\nThis is a greedy and blind implementation that tries to consume as much\ninput as possible and that does not consider what comes afterwards.\n\nFor example, the parser [:letter().plus():] accepts any sequence of\nletters and returns a list of the parsed letters.\n","line":"106"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"times1()","name":"times","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"count","name":"count","kind":"param"}],"kind":"method","comment":"\nReturns a parser that accepts the receiver exactly [count] times. The\nresulting parser returns a list of the parse results of the receiver.\n\nFor example, the parser [:letter().times(2):] accepts two letters and\nreturns a list of the two parsed letters.\n","line":"115"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"repeat2()","name":"repeat","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"min","name":"min","kind":"param"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"max","name":"max","kind":"param"}],"kind":"method","comment":"\nReturns a parser that accepts the receiver between [min] and [max] times.\nThe resulting parser returns a list of the parse results of the receiver.\n\nThis is a greedy and blind implementation that tries to consume as much\ninput as possible and that does not consider what comes afterwards.\n\nFor example, the parser [:letter().repeat(2, 4):] accepts a sequence of\ntwo, three, or four letters and returns the accepted letters as a list.\n","line":"127"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"seq1()","name":"seq","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"other","name":"other","kind":"param"}],"kind":"method","comment":"\nReturns a parser that accepts the receiver followed by [other]. The\nresulting parser returns a list of the parse result of the receiver\nfollowed by the parse result of [other]. Calling [SequenceParser.seq]\ncauses the sequences to be concatenated instead of nested.\n\nFor example, the parser [:letter().seq(digit()).seq(letter()):] accepts a\nletter followed by a digit and another letter. The parse result of the\ninput string [:'a1b':] is the list [:['a', '1', 'b']:].\n","line":"139"},{"isOperator":true,"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"&1()","name":"&","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"other","name":"other","kind":"param"}],"kind":"method","comment":"\nConvenience operator returning a parser accepts the receiver followed\nby [other]. See [Parser.seq] for details.\n","line":"145"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"or1()","name":"or","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"other","name":"other","kind":"param"}],"kind":"method","comment":"\nReturns a parser that accepts the receiver or [other]. The resulting\nparser returns the parse result of the receiver, if the receiver fails\nit returns the parse result of [other] (exclusive ordered choice).\n\nFor example, the parser [:letter().or(digit()):] accepts a letter or a\ndigit. An example where the order matters is the following choice between\noverlapping parsers: [:letter().or(char('a')):]. In the example the parser\n[:char('a'):] will never be activated, because the input is always consumed\n[:letter():]. This can be problematic if the author intended to attach a\nproduction action to [:char('a'):].\n","line":"159"},{"isOperator":true,"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"|1()","name":"|","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"other","name":"other","kind":"param"}],"kind":"method","comment":"\nConvenience operator returning a parser accepts the receiver or\n[other]. See [Parser.or] for details.\n","line":"165"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"and0()","name":"and","kind":"method","comment":"\nReturns a parser (logical and-predicate) that succeeds whenever the\nreceiver does, but never consumes input.\n\nFor example, the parser [:char('_').and().seq(identifier):] accepts\nidentifiers that start with an underscore character. Since the predicate\ndoes not consume accepted input, the parser [:identifier:] is given the\nability to process the complete identifier.\n","line":"176"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"not1()","name":"not","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"message","name":"message","kind":"param"}],"kind":"method","comment":"\nReturns a parser (logical not-predicate) that succeeds whenever the\nreceiver fails, but never consumes input.\n\nFor example, the parser [:char('_').not().seq(identifier):] accepts\nidentifiers that do not start with an underscore character. If the parser\n[:char('_'):] accepts the input, the negation and subsequently the\ncomplete parser fails. Otherwise the parser [:identifier:] is given the\nability to process the complete identifier.\n","line":"188"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"neg1()","name":"neg","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"message","name":"message","kind":"param"}],"kind":"method","comment":"\nReturns a parser that consumes any input token (character), but the\nreceiver.\n\nFor example, the parser [:letter().neg():] accepts any input but a letter.\nThe parser fails for inputs like [:'a':] or [:'Z':], but succeeds for\ninput like [:'1':], [:'_':] or [:'$':].\n","line":"198"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"flatten0()","name":"flatten","kind":"method","comment":"\nReturns a parser that discards the result of the receiver, and returns\na sub-string of the consumed elements in the string/list being parsed.\n\nFor example, the parser [:letter().plus().flatten():] returns [:'abc':]\nfor the input [:'abc':]. In contrast, the parser [:letter().plus():] would\nreturn [:['a', 'b', 'c']:] for the same input instead.\n","line":"208"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"token0()","name":"token","kind":"method","comment":"\nReturns a parser that discards the result of the receiver and returns\na [Token]. The token carries information about where the token started and\nstopped in the input stream.\n\nFor example, the parser [:letter().plus().token():] returns the token\n[:Token[start: 0, stop: 3, value: abc]:] for the input [:'abc':].\n","line":"218"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"trim1()","name":"trim","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"isOptional":true,"id":"trimmer","name":"trimmer","kind":"param"}],"kind":"method","comment":"\nReturns a parser that consumes input before and after the receiver. The\noptional argument [trimmer] is a parser that consumes the excess input. By\ndefault [:whitespace():] is used.\n\nFor example, the parser [:letter().plus().trim():] returns [:['a', 'b']:]\nfor the input [:' ab\\n':] and consumes the complete input string.\n","line":"228"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"end1()","name":"end","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"defaultValue":"'end of input expected'","isOptional":true,"id":"message","name":"message","kind":"param"}],"kind":"method","comment":"\nReturns a parser that succeeds only if the receiver consumes the complete\ninput, otherwise return a failure with the optional [message].\n\nFor example, the parser [:letter().end():] succeeds on the input [:'a':]\nand fails on [:'ab':]. In contrast the parser [:letter():] alone would\nsucceed on both inputs, but not consume everything for the second input.\n","line":"240"},{"returnType":{"name":"SetableParser","refId":"petitparser/SetableParser"},"id":"setable0()","name":"setable","kind":"method","comment":"\nReturns a parser that points to the receiver, but can be changed to point\nto something else at a later point in time.\n\nFor example, the parser [:letter().setable():] behaves exactly the same\nas [:letter():], but it can be replaced with another parser using\n[SetableParser.set].\n","line":"252"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"map1()","name":"map","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"function","name":"function","kind":"param"}],"kind":"method","comment":"\nReturns a parser that evaluates [function] as action handler on success\nof the receiver.\n\nFor example, the parser [:digit().map((char) => int.parse(char)):] returns\nthe number [:1:] for the input string [:'1':].\n","line":"261"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"pick1()","name":"pick","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"index","name":"index","kind":"param"}],"kind":"method","comment":"\nReturns a parser that transform a successful parse result by returning\nthe element at [index] of a list. A negative index can be used to access\nthe elements from the back of the list.\n\nFor example, the parser [:letter().star().pick(-1):] returns the last\nletter parsed. For the input [:'abc':] it returns [:'c':].\n","line":"271"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"permute1()","name":"permute","children":[{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"int","refId":"dart.core/int"}]},"id":"indexes","name":"indexes","kind":"param"}],"kind":"method","comment":"\nReturns a parser that transforms a successful parse result by returning\nthe permuted elements at [indexes] of a list. Negative indexes can be\nused to access the elements from the back of the list.\n\nFor example, the parser [:letter().star().permute([0, -1]):] returns the\nfirst and last letter parsed. For the input [:'abc':] it returns\n[:['a', 'c']:].\n","line":"286"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"separatedBy3()","name":"separatedBy","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"separator","name":"separator","kind":"param"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isNamed":true,"defaultValue":"true","isOptional":true,"id":"includeSeparators","name":"includeSeparators","kind":"param"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isNamed":true,"defaultValue":"false","isOptional":true,"id":"optionalSeparatorAtEnd","name":"optionalSeparatorAtEnd","kind":"param","line":"310"}],"kind":"method","comment":"\nReturns a parser that consumes the receiver one or more times separated\nby the [separator] parser. The resulting parser returns a flat list of\nthe parse results of the receiver interleaved with the parse result of the\nseparator parser.\n\nIf the optional argument [includeSeparators] is set to [:false:], then the\nseparators are not included in the parse result. If the optional argument\n[optionalSeparatorAtEnd] is set to [:true:] the parser also accepts an\noptional separator at the end.\n\nFor example, the parser [:digit().separatedBy(char('-')):] returns a parser\nthat consumes input like [:'1-2-3':] and returns a list of the elements and\nseparators: [:['1', '-', '2', '-', '3']:].\n","line":"309"},{"returnType":{"name":"void","refId":"void"},"id":"replace2()","name":"replace","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"source","name":"source","kind":"param"},{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"target","name":"target","kind":"param"}],"kind":"method","comment":"\nChanges the receiver by replacing [source] with [target]. Does nothing\nif [source] does not exist in [Parser.children].\n\nThe following example creates a letter parser and then defines a parser\ncalled [:example:] that accepts one or more letters. Eventually the parser\n[:example:] is modified by replacing the [:letter:] parser with a new\nparser that accepts a digit. The resulting [:example:] parser accepts one\nor more digits.\n\n    var letter = letter();\n    var example = letter.plus();\n    example.replace(letter, digit());\n","line":"358"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"Parser","refId":"petitparser/Parser"}]},"id":"children","name":"children","kind":"property","comment":"\nReturns a list of directly referenced parsers.\n\nFor example, [:letter().children:] returns the empty collection [:[]:],\nbecause the letter parser is a primitive or leaf parser that does not\ndepend or call any other parser.\n\nIn contrast, [:letter().or(digit()).children:] returns a collection\ncontaining both the [:letter():] and [:digit():] parser.\n","line":"342"}],"uri":"package:petitparser/src/core/parser.dart","kind":"class","comment":"\nAbstract base class of all parsers.\n","line":"8"},{"superclass":{"name":"_SetableParser","refId":"petitparser/_SetableParser"},"isAbstract":true,"id":"CompositeParser","name":"CompositeParser","children":[{"returnType":{"name":"void","refId":"void"},"id":"initialize0()","name":"initialize","kind":"method","comment":"\nInitializes the composite grammar.\n","line":"52"},{"returnType":{"name":"void","refId":"void"},"id":"_complete0()","name":"_complete","kind":"method","comment":"\nInternal method to complete the grammar.\n","isPrivate":true,"line":"57"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"ref1()","name":"ref","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"}],"kind":"method","comment":"\nReturns a reference to a production with a [name].\n\nThis method works during initialization and after completion of the\ninitialization. During the initialization it returns delegate parsers\nthat are eventually replaced by the real parsers. Afterwards it\nreturns the defined parser (mostly useful for testing).\n","line":"78"},{"isOperator":true,"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"[]1()","name":"[]","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"}],"kind":"method","comment":"\nConvenience operator returning a reference to a production with\na [name]. See [CompositeParser.ref] for details.\n","line":"96"},{"returnType":{"name":"void","refId":"void"},"id":"def2()","name":"def","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"},{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"parser","name":"parser","kind":"param"}],"kind":"method","comment":"\nDefines a production with a [name] and a [parser]. Only call this method\nfrom [initialize].\n\nThe following example defines a list production that consumes\nseveral elements separated by a comma.\n\n    def('list', ref('element').separatedBy(char(',')));\n","line":"107"},{"returnType":{"name":"void","refId":"void"},"id":"redef2()","name":"redef","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"},{"id":"replacement","name":"replacement","kind":"param"}],"kind":"method","comment":"\nRedefinies an existing production with a [name] and a [replacement]\nparser or function producing a new parser. The code raises an\n[UndefinedProductionError] if [name] is an undefined production. Only call\nthis method from [initialize].\n\nThe following example redefines the previously defined list production\nby making it optional:\n\n    redef('list', (parser) => parser.optional());\n","line":"128"},{"returnType":{"name":"void","refId":"void"},"id":"action2()","name":"action","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"function","name":"function","children":[{"id":"Function","name":"Function","children":[{"id":"Dynamic","name":"Dynamic","uri":"package:petitparser/src/core/composite.dart","kind":"param","line":"149"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nAttaches an action [function] to an existing production [name]. The code\nraises an [UndefinedProductionError] if [name] is an undefined production.\nOnly call this method from [initialize].\n\nThe following example attaches an action returning the size of list of\nthe previously defined list production:\n\n    action('list', (list) => list.length);\n","line":"149"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"_completed","name":"_completed","kind":"variable","isPrivate":true,"line":"40"},{"isFinal":true,"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"},{"name":"Parser","refId":"petitparser/Parser"}]},"id":"_defined","name":"_defined","kind":"variable","isPrivate":true,"line":"41"},{"isFinal":true,"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"},{"name":"SetableParser","refId":"petitparser/SetableParser"}]},"id":"_undefined","name":"_undefined","kind":"variable","isPrivate":true,"line":"42"},{"id":"CompositeParser0()","name":"CompositeParser","kind":"constructor","line":"44"}],"uri":"package:petitparser/src/core/composite.dart","kind":"class","comment":"\nHelper to compose complex grammars from various primitive parsers.\n\nTo create a new composite grammar subclass [CompositeParser]. Override\nthe method [initialize] and for every production call [def] giving the\nproduction a name. The start production must be named 'start'. To refer\nto other produtions (forward and backward) use [ref].\n\nConsider the following example to parse a list of numbers:\n\n    class NumberListGrammar extends CompositeParser {\n      void initialize() {\n        def('element', digit().plus().flatten());\n        def('list', ref('element').separatedBy(char(',')));\n        def('start', ref('list').end());\n      }\n    }\n\nYou might want to create future subclasses of your composite grammar\nto redefine the grammar or attach custom actions. In such a subclass\noverride the method [initialize] again and call super. Then use\n[redef] to redefine an existing production, and [action] to attach an\naction to an existing production.\n\nConsider the following example that attaches a production action and\nconverts the digits to actual numbers:\n\n    class NumberListParser extends NumberListGrammar {\n      void initialize() {\n        action('element', (value) => int.parse(value));\n      }\n    }\n","line":"38"},{"superclass":{"name":"Parser","refId":"petitparser/Parser"},"id":"_DelegateParser","name":"_DelegateParser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","isPrivate":true,"line":"15"},{"returnType":{"name":"void","refId":"void"},"id":"replace2()","name":"replace","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"source","name":"source","kind":"param"},{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"target","name":"target","kind":"param"}],"kind":"method","line":"21"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"Parser","refId":"petitparser/Parser"}]},"id":"children","name":"children","kind":"property","line":"19"},{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"_delegate","name":"_delegate","kind":"variable","isPrivate":true,"line":"11"},{"id":"_DelegateParser1()","name":"_DelegateParser","children":[{"initializedField":{"name":"_delegate","refId":"petitparser/_DelegateParser/_delegate"},"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"_delegate","name":"_delegate","kind":"param","isPrivate":true}],"kind":"constructor","line":"13"}],"uri":"package:petitparser/src/core/combinators.dart","kind":"class","comment":"\nA parser that delegates to another one. Normally users do not need to\ndirectly use a delegate parser.\n","isPrivate":true,"line":"9"}],"uri":"package:petitparser/petitparser.dart","kind":"library","comment":"\n# Writing a Simple Grammar\n\nWriting grammars with PetitParser is simple as writing Dart code. For\nexample, to write a grammar that can parse identifiers that start with\na letter followed by zero or more letter or digits is defined as follows:\n\n    Parser id = letter().seq(letter().or(digit()).star());\n\nIf you look at the object [:id:] in the debugger, you'll notice\nthat the code above buils a tree of parser objects:\n\n- Sequence: This parser accepts a sequence of parsers.\n- - Predicate: This parser accepts a single letter.\n- - Repeater: This parser accepts zero or more times another parser.\n- - - Choice: This parser accepts a single word character.\n- - - - Predicate: This parser accepts a single letter.\n- - - - Predicate: This parser accepts a single digit.\n\n# Parsing Some Input\n\nTo actually parse a [String] (or [List]) we can use the method\n[Parser.parse]:\n\n    Result id1 = id.parse('yeah');\n    Result id2 = id.parse('f12');\n\nThe method [Parser.parse] returns a parse [Result], which is either an\ninstance of [Success] or [Failure]. In both examples above we are\nsuccessful and can retrieve the parse result using [Success.result]:\n\n    print(id1.result);                  // ['y', ['e', 'a', 'h']]\n    print(id2.result);                  // ['f', ['1', '2']]\n\nWhile it seems odd to get these nested arrays with characters as a return\nvalue, this is the default decomposition of the input into a parse tree.\nWe'll see in a while how that can be customized.\n\nIf we try to parse something invalid we get an instance of [Failure] as\nan answer and we can retrieve a descriptive error message using\n[Failure.message]:\n\n    Result id3 = id.parse('123');\n    print(id3.message);                // 'letter expected'\n    print(id3.position);               // 0\n\nTrying to retrieve the parse result by calling [Failure.result] would throw\nthe exception [UnsupportedError]. [Result.isSuccess] and [Result.isFailure]\ncan be used to decide if the parse was successful.\n\nIf you are only interested if a given string matches or not you can use the\nhelper method [Parser.accept]:\n\n    print(id.accept('foo'));            // true\n    print(id.accept('123'));            // false\n\n# Different Kinds of Parsers\n\nPetitParser provide a large set of ready-made parser that you can compose\nto consume and transform arbitrarily complex languages. The terminal parsers\nare the most simple ones. We've already seen a few of those:\n\n  * [:char('a'):] parses the character *a*.\n  * [:string('abc'):] parses the string *abc*.\n  * [:any():] parses any character.\n  * [:digit():] parses any digit from *0* to *9*.\n  * [:letter():] parses any letter from *a* to *z* and *A* to *Z*.\n  * [:word():] parses any letter or digit.\n\nSo instead of using the letter and digit predicate, we could have written\nour identifier parser like this:\n\n    var id = letter().seq(word().star());\n\nThe next set of parsers are used to combine other parsers together:\n\n  * [:p1.seq(p2):] and [:p1 & p2:] parse *p1* followed by *p2* (sequence).\n  * [:p1.or(p2):] and [:p1 | p2:] parse *p1*, if that doesn't work parses *p2* (ordered choice).\n  * [:p.star():] parses *p* zero or more times.\n  * [:p.plus():] parses *p* one or more times.\n  * [:p.optional():] parses *p*, if possible.\n  * [:p.and():] parses *p*, but does not consume its input.\n  * [:p.not():] parses *p* and succeed when p fails, but does not consume its input.\n  * [:p.end():] parses *p* and succeed at the end of the input.\n\nTo attach an action or transformation to a parser we can use the following\nmethods:\n\n  * [:p.map((value) => ...):] performs the transformation given the function.\n  * [:p.pick(n):] returns the *n*-th element of the list *p* returns.\n  * [:p.flatten():] creates a string from the result of *p*.\n  * [:p.token():] creates a token from the result of *p*.\n  * [:p.trim():] trims whitespaces before and after *p*.\n\nTo return a string of the parsed identifier, we can modify our parser like\nthis:\n\n    var id = letter().seq(word().star()).flatten();\n\nTo conveniently find all matches in a given input string you can use\n[Parser.matchesSkipping]:\n\n    var matches = id.matchesSkipping('foo 123 bar4');\n    print(matches);                    // ['foo', 'bar4']\n\n\nThese are the basic elements to build parsers. There are a few more well\ndocumented and tested factory methods in the [Parser] class. If you want\nbrowse their documentation and tests.\n\n# Writing a More Complicated Grammar\n\nNow we are able to write a more complicated grammar for evaluating simple\narithmetic expressions. Within a file we start with the grammar for a\nnumber (actually an integer):\n\n    var number = digit().plus().flatten().trim().map(int.parse);\n\nThen we define the productions for addition and multiplication in order of\nprecedence. Note that we instantiate the productions with undefined parsers\nupfront, because they recursively refer to each other. Later on we can\nresolve this recursion by setting their reference:\n\n    var term = undefined();\n    var prod = undefined();\n    var prim = undefined();\n\n    term.set(prod.seq(char('+').trim()).seq(term).map((values) {\n      return values[0] + values[2];\n    }).or(prod));\n    prod.set(prim.seq(char('*').trim()).seq(prod).map((values) {\n      return values[0] * values[2];\n    }).or(prim));\n    prim.set(char('(').trim().seq(term).seq(char(')'.trim())).map((values) {\n      return values[1];\n    }).or(number));\n\nTo make sure that our parser consumes all input we wrap it with the [:end():]\nparser into the start production:\n\n    var start = term.end();\n\nThat's it, now we can test our parser and evaluator:\n\n    print(start.parse('1 + 2 * 3').result);       // 7\n    print(start.parse('(1 + 2) * 3').result);     // 9\n\nAs an exercise we could extend the parser to also accept negative numbers\nand floating point numbers, not only integers. Furthermore it would be\nuseful to support subtraction and division as well. All these features\ncan be added with a few lines of PetitParser code.\n","line":"155"}],"id":"json","children":[{"superclass":{"name":"JsonGrammar","refId":"json/JsonGrammar"},"id":"JsonParser","name":"JsonParser","children":[{"returnType":{"name":"void","refId":"void"},"id":"initialize0()","name":"initialize","kind":"method","line":"10"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/json/parser.dart","kind":"class","comment":"\nJSON parser definition.\n","line":"8"},{"superclass":{"name":"CompositeParser","refId":"petitparser/CompositeParser"},"id":"JsonGrammar","name":"JsonGrammar","children":[{"returnType":{"name":"void","refId":"void"},"id":"initialize0()","name":"initialize","kind":"method","line":"21"},{"isFinal":true,"id":"_escapeTable","name":"_escapeTable","kind":"variable","isPrivate":true,"line":"10"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/json/grammar.dart","kind":"class","comment":"\nJSON grammar definition.\n","line":"8"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/json.dart","kind":"library","line":"3"}