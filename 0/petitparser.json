{"dependencies":[{"id":"dart.core","name":"dart:core","children":[{"id":"Object","name":"Object","children":[{"isOperator":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"==1()","name":"==","children":[{"id":"other","name":"other","kind":"param"}],"kind":"method","comment":"\nThe equality operator.\n\nThe default behavior for all [Object]s is to return true if and\nonly if [:this:] and [other] are the same object.\n\nIf a subclass overrides the equality operator it should override\nthe [hashCode] method as well to maintain consistency.\n","line":"29"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"toString0()","name":"toString","kind":"method","comment":"\nReturns a string representation of this object.\n","line":"48"},{"id":"noSuchMethod1()","name":"noSuchMethod","children":[{"ref":{"name":"InvocationMirror","refId":"dart.core/InvocationMirror"},"id":"invocation","name":"invocation","kind":"param"}],"kind":"method","comment":"\n[noSuchMethod] is invoked when users invoke a non-existant method\non an object. The name of the method and the arguments of the\ninvocation are passed to [noSuchMethod] in an [InvocationMirror].\nIf [noSuchMethod] returns a value, that value becomes the result of\nthe original invocation.\n\nThe default behavior of [noSuchMethod] is to throw a\n[noSuchMethodError].\n","line":"60"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"hashCode","name":"hashCode","kind":"property","comment":"\nGet a hash code for this object.\n\nAll objects have hash codes. Hash codes are guaranteed to be the\nsame for objects that are equal when compared using the equality\noperator [:==:]. Other than that there are no guarantees about\nthe hash codes. They will not be consistent between runs and\nthere are no distribution guarantees.\n\nIf a subclass overrides [hashCode] it should override the\nequality operator as well to maintain consistency.\n","line":"43"},{"ref":{"name":"Type","refId":"dart.core/Type"},"id":"runtimeType","name":"runtimeType","kind":"property","comment":"\nA representation of the runtime type of the object.\n","line":"65"},{"id":"Object0()","name":"Object","kind":"constructor","comment":"\nCreates a new [Object] instance.\n\n[Object] instances have no meaningful state, and are only useful\nthrough their identity. An [Object] instance is equal to itself\nonly.\n","line":"18"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/object.dart","kind":"class","comment":"\nEverything in Dart is an [Object].\n","line":"10"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"id":"Iterator","name":"Iterator","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"moveNext0()","name":"moveNext","kind":"method","comment":"\nMoves to the next element. Returns true if [current] contains the next\nelement. Returns false, if no element was left.\n\nIt is safe to invoke [moveNext] even when the iterator is already\npositioned after the last element. In this case [moveNext] has no effect.\n","line":"35"},{"ref":{"name":"E","refId":"dart.core/Iterator/E"},"id":"current","name":"current","kind":"property","comment":"\nReturns the current element.\n\nReturn [:null:] if the iterator has not yet been moved to the first\nelement, or if the iterator has been moved after the last element of the\n[Iterable].\n","line":"44"},{"id":"E","name":"E","kind":"typeparam"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterator.dart","kind":"class","comment":"\nThe [Iterator] class provides methods to iterate over an object. It\nis transparently used by the for-in construct to test for the end\nof the iteration, and to get the elements.\n\nIf the object iterated over is changed during the iteration, the\nbehavior is unspecified.\n\nThe [Iterator] is initially positioned before the first element. Before\naccessing the first element the iterator must thus be advanced ([moveNext])\nto point to the first element. If there is no element left, then [moveNext]\nreturns false.\n\nA typical usage of an [Iterator] looks as follows:\n\n    var it = obj.iterator;\n    while (it.moveNext()) {\n      use(it.current);\n    }\n","line":"27"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"id":"Iterable","name":"Iterable","children":[{"returnType":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"map1()","name":"map","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"51"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns a lazy [Iterable] where each element [:e:] of [this] is replaced\nby the result of [:f(e):].\n\nThis method returns a view of the mapped elements. As long as the\nreturned [Iterable] is not iterated over, the supplied function [f] will\nnot be invoked. The transformed elements will not be cached. Iterating\nmultiple times over the the returned [Iterable] will invoke the supplied\nfunction [f] multiple times on the same element.\n","line":"51"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"where1()","name":"where","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"63"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns a lazy [Iterable] with all elements that satisfy the\npredicate [f].\n\nThis method returns a view of the mapped elements. As long as the\nreturned [Iterable] is not iterated over, the supplied function [f] will\nnot be invoked. Iterating will not cache results, and thus iterating\nmultiple times over the the returned [Iterable] will invoke the supplied\nfunction [f] multiple times on the same element.\n","line":"63"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"expand1()","name":"expand","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"returnType":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"75"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nExpand each element of this [Iterable] into zero or more elements.\n\nThe resulting Iterable will run through the elements returned\nby [f] for each element of this, in order.\n\nThe returned [Iterable] is lazy, and will call [f] for each element\nof this every time it's iterated.\n","line":"75"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"contains1()","name":"contains","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","kind":"param"}],"kind":"method","comment":"\nCheck whether the collection contains an element equal to [element].\n","line":"81"},{"returnType":{"name":"void","refId":"void"},"id":"forEach1()","name":"forEach","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"returnType":{"name":"void","refId":"void"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"91"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nApplies the function [f] to each element of this collection.\n","line":"91"},{"id":"reduce2()","name":"reduce","children":[{"id":"initialValue","name":"initialValue","kind":"param","line":"109"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"combine","name":"combine","children":[{"id":"Function","name":"Function","children":[{"id":"previousValue","name":"previousValue","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"110"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"110"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param","line":"110"}],"kind":"method","comment":"\nReduce a collection to a single value by iteratively combining each element\nof the collection with an existing value using the provided function.\nUse [initialValue] as the initial value, and the function [combine] to\ncreate a new value from the previous one and an element.\n\nExample of calculating the sum of an iterable:\n\n  iterable.reduce((prev, element) => prev + element);\n\n*UPCOMING API-CHANGE*: this method will soon be changed to not take\nan initial value: `iterable.reduce(min)`. Use [fold] instead.\n","line":"108"},{"id":"fold2()","name":"fold","children":[{"id":"initialValue","name":"initialValue","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"combine","name":"combine","children":[{"id":"Function","name":"Function","children":[{"id":"previousValue","name":"previousValue","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"125"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"125"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param","line":"125"}],"kind":"method","comment":"\nReduce a collection to a single value by iteratively combining each element\nof the collection with an existing value using the provided function.\nUse [initialValue] as the initial value, and the function [combine] to\ncreate a new value from the previous one and an element.\n\nExample of calculating the sum of an iterable:\n\n  iterable.fold(0, (prev, element) => prev + element);\n","line":"124"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"every1()","name":"every","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"135"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns true if every elements of this collection satisify the\npredicate [f]. Returns false otherwise.\n","line":"135"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"join1()","name":"join","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"separator","name":"separator","kind":"param"}],"kind":"method","comment":"\nConvert each element to a [String] and concatenate the strings.\n\nConverts each element to a [String] by calling [Object.toString] on it.\nThen concatenates the strings, optionally separated by the [separator]\nstring.\n","line":"149"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"any1()","name":"any","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"f","name":"f","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"element","name":"element","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"159"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns true if one element of this collection satisfies the\npredicate [f]. Returns false otherwise.\n","line":"159"},{"returnType":{"name":"List","refId":"dart.core/List","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"toList1()","name":"toList","children":[{"ref":{"name":"bool","refId":"dart.core/bool"},"isNamed":true,"defaultValue":"true","isOptional":true,"id":"growable","name":"growable","kind":"param"}],"kind":"method","line":"166"},{"returnType":{"name":"Set","refId":"dart.core/Set","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"toSet0()","name":"toSet","kind":"method","line":"168"},{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"min1()","name":"min","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"isOptional":true,"id":"compare","name":"compare","children":[{"returnType":{"name":"int","refId":"dart.core/int"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"a","name":"a","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"199"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"b","name":"b","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"199"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param","line":"199"}],"kind":"method","comment":"\nFind the least element in the iterable.\n\nReturns null if the iterable is empty.\nOtherwise returns an element [:x:] of this [Iterable] so that\n[:x:] is not greater than [:y:] (that is, [:compare(x, y) <= 0:]) for all\nother elements [:y:] in the iterable.\n\nThe [compare] function must be a proper [Comparator<T>]. If a function is\nnot provided, [compare] defaults to [Comparable.compare].\n\n*Deprecated*. Use [reduce] with a binary min method if needed.\n","line":"198"},{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"max1()","name":"max","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"isOptional":true,"id":"compare","name":"compare","children":[{"returnType":{"name":"int","refId":"dart.core/int"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"a","name":"a","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"225"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"b","name":"b","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"225"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param","line":"225"}],"kind":"method","comment":"\nFind the largest element in the iterable.\n\nReturns null if the iterable is empty.\nOtherwise returns an element [:x:] of this [Iterable] so that\n[:x:] is not smaller than [:y:] (that is, [:compare(x, y) >= 0:]) for all\nother elements [:y:] in the iterable.\n\nThe [compare] function must be a proper [Comparator<T>]. If a function is\nnot provided, [compare] defaults to [Comparable.compare].\n\n*Deprecated*. Use [reduce] with a binary max method if needed.\n","line":"224"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"take1()","name":"take","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"n","name":"n","kind":"param"}],"kind":"method","comment":"\nReturns an [Iterable] with at most [n] elements.\n\nThe returned [Iterable] may contain fewer than [n] elements, if [this]\ncontains fewer than [n] elements.\n","line":"248"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"takeWhile1()","name":"takeWhile","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"test","name":"test","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"value","name":"value","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"261"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns an [Iterable] that stops once [test] is not satisfied anymore.\n\nThe filtering happens lazily. Every new [Iterator] of the returned\n[Iterable] will start iterating over the elements of [this].\nWhen the iterator encounters an element [:e:] that does not satisfy [test],\nit discards [:e:] and moves into the finished state. That is, it will not\nask or provide any more elements.\n","line":"261"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"skip1()","name":"skip","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"n","name":"n","kind":"param"}],"kind":"method","comment":"\nReturns an [Iterable] that skips the first [n] elements.\n\nIf [this] has fewer than [n] elements, then the resulting [Iterable] will\nbe empty.\n","line":"271"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"skipWhile1()","name":"skipWhile","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"test","name":"test","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"value","name":"value","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"284"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns an [Iterable] that skips elements while [test] is satisfied.\n\nThe filtering happens lazily. Every new [Iterator] of the returned\n[Iterable] will iterate over all elements of [this].\nAs long as the iterator's elements do not satisfy [test] they are\ndiscarded. Once an element satisfies the [test] the iterator stops testing\nand uses every element unconditionally.\n","line":"284"},{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"firstWhere2()","name":"firstWhere","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"test","name":"test","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"value","name":"value","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"339"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"isNamed":true,"isOptional":true,"id":"orElse","name":"orElse","children":[{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"Function","name":"Function","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns the first element that satisfies the given predicate [f].\n\nIf none matches, the result of invoking the [orElse] function is\nreturned. By default, when [orElse] is `null`, a [StateError] is\nthrown.\n","line":"339"},{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"lastWhere2()","name":"lastWhere","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"test","name":"test","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"value","name":"value","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"355"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"isNamed":true,"isOptional":true,"id":"orElse","name":"orElse","children":[{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"Function","name":"Function","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns the last element that satisfies the given predicate [f].\n\nIf none matches, the result of invoking the [orElse] function is\nreturned. By default, when [orElse] is [:null:], a [StateError] is\nthrown.\n","line":"355"},{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"singleWhere1()","name":"singleWhere","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"test","name":"test","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"Function","name":"Function","children":[{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"value","name":"value","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"374"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nReturns the single element that satisfies [f]. If no or more than one\nelement match then a [StateError] is thrown.\n","line":"374"},{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"elementAt1()","name":"elementAt","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"index","name":"index","kind":"param"}],"kind":"method","comment":"\nReturns the [index]th element.\n\nIf [this] [Iterable] has fewer than [index] elements throws a\n[RangeError].\n\nNote: if [this] does not have a deterministic iteration order then the\nfunction may simply return any element without any iteration if there are\nat least [index] elements in [this].\n","line":"401"},{"ref":{"name":"Iterator","refId":"dart.core/Iterator","arguments":[{"name":"E","refId":"dart.core/Iterable/E"}]},"id":"iterator","name":"iterator","kind":"property","comment":"\nReturns an [Iterator] that iterates over this [Iterable] object.\n","line":"39"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"length","name":"length","kind":"property","comment":"\nReturns the number of elements in [this].\n\nCounting all elements may be involve running through all elements and can\ntherefore be slow.\n","line":"176"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"isEmpty","name":"isEmpty","kind":"property","comment":"\nReturns true if there is no element in this collection.\n","line":"240"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"first","name":"first","kind":"property","comment":"\nReturns the first element.\n\nIf [this] is empty throws a [StateError]. Otherwise this method is\nequivalent to [:this.elementAt(0):]\n","line":"294"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"last","name":"last","kind":"property","comment":"\nReturns the last element.\n\nIf [this] is empty throws a [StateError].\n","line":"307"},{"ref":{"name":"E","refId":"dart.core/Iterable/E"},"id":"single","name":"single","kind":"property","comment":"\nReturns the single element in [this].\n\nIf [this] is empty or has more than one element throws a [StateError].\n","line":"324"},{"id":"Iterable0()","name":"Iterable","kind":"constructor","line":"20"},{"id":"Iterable.generate2()","name":"Iterable.generate","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"count","name":"count","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"generator","name":"generator","children":[{"returnType":{"name":"E","refId":"dart.core/Iterable/E"},"id":"Function","name":"Function","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"index","name":"index","uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"param","line":"32"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"constructor","comment":"\nCreate an [Iterable] that generates its elements dynamically.\n\nThe [Iterators] created by the [Iterable] will count from\nzero to [:count - 1:] while iterating, and call [generator]\nwith that index to create the next value.\n\nAs an [Iterable], [:new Iterable.generate(n, generator)):] is equivalent to\n[:const [0, ..., n - 1].map(generator):]\n","line":"32"},{"id":"E","name":"E","kind":"typeparam"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/iterable.dart","kind":"class","comment":"\nThe [Iterable] interface allows to get an [Iterator] out of an\n[Iterable] object.\n\nThis interface is used by the for-in construct to iterate over an\n[Iterable] object.\nThe for-in construct takes an [Iterable] object at the right-hand\nside, and calls its [iterator] method to get an [Iterator] on it.\n\nA user-defined class that implements the [Iterable] interface can\nbe used as the right-hand side of a for-in construct.\n","line":"19"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isThrowable":true,"id":"Error","name":"Error","children":[{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"safeToString1()","name":"safeToString","children":[{"ref":{"name":"Object","refId":"dart.core/Object"},"id":"object","name":"object","kind":"param"}],"kind":"method","comment":"\nSafely convert a value to a [String] description.\n\nThe conversion is guaranteed to not throw, so it won't use the object's\ntoString method.\n","line":"16"},{"isStatic":true,"returnType":{"name":"String","refId":"dart.core/String"},"id":"_objectToString1()","name":"_objectToString","children":[{"ref":{"name":"Object","refId":"dart.core/Object"},"id":"object","name":"object","kind":"param"}],"kind":"method","isPrivate":true,"line":"34"},{"id":"Error0()","name":"Error","kind":"constructor","line":"8"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/errors.dart","kind":"class","line":"7"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/core.dart","kind":"library","line":"5"}],"id":"petitparser","children":[{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"stringIgnoreCase2()","name":"stringIgnoreCase","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"element","name":"element","kind":"param"},{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"isOptional":true,"id":"message","name":"message","kind":"param"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/predicates.dart","kind":"method","comment":"\nReturns a parser that accepts the string [element] ignoring the case.\n\nFor example, [:stringIgnoreCase('foo'):] succeeds and consumes the input\nstring [:'Foo':] or [:'FOO':]. Fails for any other input.\n","line":"47"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"string2()","name":"string","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"element","name":"element","kind":"param"},{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"isOptional":true,"id":"message","name":"message","kind":"param"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/predicates.dart","kind":"method","comment":"\nReturns a parser that accepts the string [element].\n\nFor example, [:string('foo'):] succeeds and consumes the input string\n[:'foo':]. Fails for any other input.\n","line":"35"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"anyIn2()","name":"anyIn","children":[{"id":"elements","name":"elements","kind":"param"},{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"isOptional":true,"id":"message","name":"message","kind":"param"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/predicates.dart","kind":"method","comment":"\nReturns a parser that accepts any of the [elements].\n\nFor example, [:anyIn('ab'):] succeeds and consumes either the letter\n[:'a':] or the letter [:'b':]. For any other input the parser fails.\n","line":"23"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"any1()","name":"any","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"isOptional":true,"id":"message","name":"message","kind":"param"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/predicates.dart","kind":"method","comment":"\nReturns a parser that accepts any input element.\n\nFor example, [:any():] succeeds and consumes any given letter. It only\nfails for an empty input.\n","line":"11"},{"returnType":{"name":"SetableParser","refId":"petitparser/SetableParser"},"id":"undefined1()","name":"undefined","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"defaultValue":"'undefined parser'","isOptional":true,"id":"message","name":"message","kind":"param"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/parsers.dart","kind":"method","comment":"\nReturns a parser that is not defined, but that can be set at a later\npoint in time.\n\nFor example, the following code sets up a parser that points to itself\nand that accepts a sequence of a's ended with the letter b.\n\n    var p = undefined();\n    p.set(char('a').seq(p).or(char('b')));\n","line":"44"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"failure1()","name":"failure","children":[{"ref":{"name":"String","refId":"dart.core/String"},"defaultValue":"'unable to parse'","isOptional":true,"id":"message","name":"message","kind":"param"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/parsers.dart","kind":"method","comment":"\nReturns a parser that consumes nothing and fails.\n\nFor example, [:failure():] always fails, no matter what input it is given.\n","line":"24"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"epsilon1()","name":"epsilon","children":[{"isNamed":true,"isOptional":true,"id":"result","name":"result","kind":"param"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/parsers.dart","kind":"method","comment":"\nReturns a parser that consumes nothing and succeeds.\n\nFor example, [:char('a').or(epsilon()):] is equivalent to\n[:char('a').optional():].\n","line":"11"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"word1()","name":"word","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"isOptional":true,"id":"message","name":"message","kind":"param"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"method","comment":"Returns a parser that accepts any word character. ","line":"189"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"whitespace1()","name":"whitespace","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"isOptional":true,"id":"message","name":"message","kind":"param"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"method","comment":"Returns a parser that accepts any whitespace character. ","line":"177"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"uppercase1()","name":"uppercase","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"isOptional":true,"id":"message","name":"message","kind":"param"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"method","comment":"Returns a parser that accepts any uppercase character. ","line":"167"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"range3()","name":"range","children":[{"id":"start","name":"start","kind":"param"},{"id":"stop","name":"stop","kind":"param"},{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"isOptional":true,"id":"message","name":"message","kind":"param"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"method","comment":"Returns a parser that accepts any character in the range between [start] and [stop]. "},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"pattern2()","name":"pattern","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"element","name":"element","kind":"param"},{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"isOptional":true,"id":"message","name":"message","kind":"param"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"method","comment":"Returns a parser that accepts the given character class pattern. ","line":"132"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"lowercase1()","name":"lowercase","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"isOptional":true,"id":"message","name":"message","kind":"param"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"method","comment":"Returns a parser that accepts any lowercase character. ","line":"122"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"letter1()","name":"letter","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"isOptional":true,"id":"message","name":"message","kind":"param"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"method","comment":"Returns a parser that accepts any letter character. ","line":"112"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"digit1()","name":"digit","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"isOptional":true,"id":"message","name":"message","kind":"param"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"method","comment":"Returns a parser that accepts any digit character. ","line":"102"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"char2()","name":"char","children":[{"id":"element","name":"element","kind":"param"},{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"isOptional":true,"id":"message","name":"message","kind":"param"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"method","comment":"Returns a parser that accepts a specific character only. ","line":"91"},{"returnType":{"name":"int","refId":"dart.core/int"},"id":"_toCharCode1()","name":"_toCharCode","children":[{"id":"element","name":"element","kind":"param"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"method","comment":"Internal method to convert an element to a character code. ","isPrivate":true,"line":"6"},{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"_pattern","name":"_pattern","uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"variable","isPrivate":true,"line":"152"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"Token","name":"Token","children":[{"isOperator":true,"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"==1()","name":"==","children":[{"ref":{"name":"Token","refId":"petitparser/Token"},"id":"other","name":"other","kind":"param"}],"kind":"method","line":"19"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"toString0()","name":"toString","kind":"method","line":"82"},{"isStatic":true,"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"newlineParser0()","name":"newlineParser","kind":"method","line":"87"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"hashCode","name":"hashCode","kind":"property","line":"26"},{"id":"value","name":"value","kind":"property","comment":"\nReturns the parsed value.\n","line":"31"},{"id":"buffer","name":"buffer","kind":"property","comment":"\nReturns the input buffer.\n","line":"37"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"start","name":"start","kind":"property","comment":"\nReturns the start position in the input buffer.\n","line":"42"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"stop","name":"stop","kind":"property","comment":"\nReturns the stop position in the input buffer.\n","line":"47"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"length","name":"length","kind":"property","comment":"\nReturns the length of the token.\n","line":"52"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"line","name":"line","kind":"property","comment":"\nReturns the line number of the token.\n","line":"57"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"column","name":"column","kind":"property","comment":"\nReturns the column number of this token.\n","line":"71"},{"isFinal":true,"id":"_value","name":"_value","kind":"variable","isPrivate":true,"line":"12"},{"isFinal":true,"id":"_buffer","name":"_buffer","kind":"variable","isPrivate":true,"line":"13"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"id":"_start","name":"_start","kind":"variable","isPrivate":true,"line":"14"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"id":"_stop","name":"_stop","kind":"variable","isPrivate":true,"line":"15"},{"isFinal":true,"ref":{"name":"Parser","refId":"petitparser/Parser"},"isStatic":true,"id":"_NEWLINE_PARSER","name":"_NEWLINE_PARSER","kind":"variable","isPrivate":true,"line":"84"},{"id":"Token4()","name":"Token","children":[{"initializedField":{"name":"_value","refId":"petitparser/Token/_value"},"id":"_value","name":"_value","kind":"param","isPrivate":true},{"initializedField":{"name":"_buffer","refId":"petitparser/Token/_buffer"},"id":"_buffer","name":"_buffer","kind":"param","isPrivate":true},{"initializedField":{"name":"_start","refId":"petitparser/Token/_start"},"ref":{"name":"int","refId":"dart.core/int"},"id":"_start","name":"_start","kind":"param","isPrivate":true},{"initializedField":{"name":"_stop","refId":"petitparser/Token/_stop"},"ref":{"name":"int","refId":"dart.core/int"},"id":"_stop","name":"_stop","kind":"param","isPrivate":true}],"kind":"constructor","line":"17"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/token.dart","kind":"class","comment":"\nA token represents a parsed part of the input stream. The token holds\nthe parsed input, the input buffer, and the start and stop position\nin the input buffer.\n","line":"10"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"Transformations","name":"Transformations","children":[{"isStatic":true,"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"transform2()","name":"transform","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"root","name":"root","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"function","name":"function","children":[{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"Function","name":"Function","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"parser","name":"parser","uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/reflection.dart","kind":"param","line":"48"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"Pluggable transformation starting at [root]. ","line":"48"},{"isStatic":true,"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"removeSetables1()","name":"removeSetables","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"root","name":"root","kind":"param"}],"kind":"method","comment":"Removes all settables starting at [root]. ","line":"73"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/reflection.dart","kind":"class","comment":"Collection of various common transformations. ","line":"45"},{"interfaces":[{"name":"Iterator","refId":"dart.core/Iterator","arguments":[{"name":"Parser","refId":"petitparser/Parser"}]}],"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"ParserIterator","name":"ParserIterator","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"moveNext0()","name":"moveNext","kind":"method","line":"29"},{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"current","name":"current","kind":"property","line":"40"},{"isFinal":true,"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"Parser","refId":"petitparser/Parser"}]},"id":"_todo","name":"_todo","kind":"variable","isPrivate":true,"line":"21"},{"isFinal":true,"ref":{"name":"Set","refId":"dart.core/Set","arguments":[{"name":"Parser","refId":"petitparser/Parser"}]},"id":"_done","name":"_done","kind":"variable","isPrivate":true,"line":"22"},{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"_current","name":"_current","kind":"variable","isPrivate":true,"line":"23"},{"id":"ParserIterator1()","name":"ParserIterator","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"root","name":"root","kind":"param"}],"kind":"constructor","line":"25"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/reflection.dart","kind":"class","comment":"Iterator over all parsers reachable from a [root]. ","line":"19"},{"superclass":{"name":"Iterable","refId":"dart.core/Iterable","arguments":[{"name":"Parser","refId":"petitparser/Parser"}]},"id":"ParserIterable","name":"ParserIterable","children":[{"ref":{"name":"ParserIterator","refId":"petitparser/ParserIterator"},"id":"iterator","name":"iterator","kind":"property","line":"12"},{"isFinal":true,"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"_root","name":"_root","kind":"variable","isPrivate":true,"line":"8"},{"id":"ParserIterable1()","name":"ParserIterable","children":[{"initializedField":{"name":"_root","refId":"petitparser/ParserIterable/_root"},"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"_root","name":"_root","kind":"param","isPrivate":true}],"kind":"constructor","line":"10"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/reflection.dart","kind":"class","comment":"Iterable over all parsers reachable from a [root]. ","line":"6"},{"superclass":{"name":"Parser","refId":"petitparser/Parser"},"id":"_PredicateParser","name":"_PredicateParser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","isPrivate":true,"line":"65"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"id":"_length","name":"_length","kind":"variable","isPrivate":true,"line":"59"},{"isFinal":true,"ref":{"name":"Function","refId":"dart.core/Function"},"id":"_predicate","name":"_predicate","kind":"variable","isPrivate":true,"line":"60"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"id":"_message","name":"_message","kind":"variable","isPrivate":true,"line":"61"},{"id":"_PredicateParser3()","name":"_PredicateParser","children":[{"initializedField":{"name":"_length","refId":"petitparser/_PredicateParser/_length"},"ref":{"name":"int","refId":"dart.core/int"},"id":"_length","name":"_length","kind":"param","isPrivate":true},{"initializedField":{"name":"_predicate","refId":"petitparser/_PredicateParser/_predicate"},"ref":{"name":"Function","refId":"dart.core/Function"},"id":"_predicate","name":"_predicate","kind":"param","isPrivate":true},{"initializedField":{"name":"_message","refId":"petitparser/_PredicateParser/_message"},"ref":{"name":"String","refId":"dart.core/String"},"id":"_message","name":"_message","kind":"param","isPrivate":true}],"kind":"constructor","line":"63"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/predicates.dart","kind":"class","comment":"\nA parser for a single literal satisfying a predicate.\n","isPrivate":true,"line":"57"},{"interfaces":[{"name":"SetableParser","refId":"petitparser/SetableParser"}],"superclass":{"name":"_DelegateParser","refId":"petitparser/_DelegateParser"},"id":"_SetableParser","name":"_SetableParser","children":[{"returnType":{"name":"void","refId":"void"},"id":"set1()","name":"set","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"parser","name":"parser","kind":"param"}],"kind":"method","line":"60"},{"id":"_SetableParser1()","name":"_SetableParser","children":[{"id":"parser","name":"parser","kind":"param"}],"kind":"constructor","line":"59"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/parsers.dart","kind":"class","isPrivate":true,"line":"58"},{"interfaces":[{"name":"Parser","refId":"petitparser/Parser"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"id":"SetableParser","name":"SetableParser","children":[{"returnType":{"name":"void","refId":"void"},"id":"set1()","name":"set","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"parser","name":"parser","kind":"param"}],"kind":"method","comment":"Sets the receiver to delegate to [parser]. ","line":"54"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/parsers.dart","kind":"class","comment":"\nInterface of a parser that can be redefined using [SetableParser.set].\n","line":"51"},{"superclass":{"name":"Parser","refId":"petitparser/Parser"},"id":"_FailureParser","name":"_FailureParser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","isPrivate":true,"line":"31"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"id":"_message","name":"_message","kind":"variable","isPrivate":true,"line":"29"},{"id":"_FailureParser1()","name":"_FailureParser","children":[{"initializedField":{"name":"_message","refId":"petitparser/_FailureParser/_message"},"ref":{"name":"String","refId":"dart.core/String"},"id":"_message","name":"_message","kind":"param","isPrivate":true}],"kind":"constructor","line":"30"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/parsers.dart","kind":"class","isPrivate":true,"line":"28"},{"superclass":{"name":"Parser","refId":"petitparser/Parser"},"id":"_EpsilonParser","name":"_EpsilonParser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","isPrivate":true,"line":"16"},{"isFinal":true,"id":"_result","name":"_result","kind":"variable","isPrivate":true,"line":"14"},{"id":"_EpsilonParser1()","name":"_EpsilonParser","children":[{"initializedField":{"name":"_result","refId":"petitparser/_EpsilonParser/_result"},"id":"_result","name":"_result","kind":"param","isPrivate":true}],"kind":"constructor","line":"15"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/parsers.dart","kind":"class","isPrivate":true,"line":"13"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"isAbstract":true,"id":"Parser","name":"Parser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","comment":"\nPrivate abstract method doing the actual parsing.\n\nThe methods takes a parse [context] and returns the resulting context,\nwhich is either a [Success] or [Failure] context.\n","isPrivate":true,"line":"16"},{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"parse1()","name":"parse","children":[{"id":"input","name":"input","kind":"param"}],"kind":"method","comment":"\nReturns the parse result of the [input].\n\nThe implementation creates a default parse context on the input and calls\nthe internal parsing logic of the receiving parser.\n\nFor example, [:letter().plus().parse('abc'):] results in an instance of\n[Success], where [Result.position] is [:3:] and [Success.result] is\n[:[a, b, c]:].\n\nSimilarly, [:letter().plus().parse('123'):] results in an instance of\n[Failure], where [Result.position] is [:0:] and [Failure.message] is\n['letter expected'].\n","line":"32"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"accept1()","name":"accept","children":[{"id":"input","name":"input","kind":"param"}],"kind":"method","comment":"\nTests if the [input] can be successfully parsed.\n\nFor example, [:letter().plus().accept('abc'):] returns [:true:], and\n[:letter().plus().accept('123'):] returns [:false:].\n","line":"42"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"matches1()","name":"matches","children":[{"id":"input","name":"input","kind":"param"}],"kind":"method","comment":"\nReturns a list of all successful overlapping parses of the [input].\n\nFor example, [:letter().plus().matches('abc de'):] results in the list\n[:[['a', 'b', 'c'], ['b', 'c'], ['c'], ['d', 'e'], ['e']]:]. See\n[Parser.matchesSkipping] to retrieve non-overlapping parse results.\n","line":"53"},{"returnType":{"name":"Iterable","refId":"dart.core/Iterable"},"id":"matchesSkipping1()","name":"matchesSkipping","children":[{"id":"input","name":"input","kind":"param"}],"kind":"method","comment":"\nReturns a list of all successful non-overlapping parses of the input.\n\nFor example, [:letter().plus().matchesSkipping('abc de'):] results in the\nlist [:[['a', 'b', 'c'], ['d', 'e']]:]. See [Parser.matches] to retrieve\noverlapping parse results.\n","line":"66"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"optional1()","name":"optional","children":[{"isOptional":true,"id":"otherwise","name":"otherwise","kind":"param"}],"kind":"method","comment":"\nReturns new parser that accepts the receiver, if possible. The resulting\nparser returns the result of the receiver, or [:null:] if not applicable.\nThe returned value can be provided as an optional argument [otherwise].\n\nFor example, the parser [:letter().optional():] accepts a letter as input\nand returns that letter. When given something else the parser succeeds as\nwell, does not consume anything and returns [:null:].\n","line":"81"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"star0()","name":"star","kind":"method","comment":"\nReturns a parser that accepts the receiver zero or more times. The\nresulting parser returns a list of the parse results of the receiver.\n\nThis is a greedy and blind implementation that tries to consume as much\ninput as possible and that does not consider what comes afterwards.\n\nFor example, the parser [:letter().star():] accepts the empty string or\nany sequence of letters and returns a possibly empty list of the parsed\nletters.\n","line":"94"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"plus0()","name":"plus","kind":"method","comment":"\nReturns a parser that accepts the receiver one or more times. The\nresulting parser returns a list of the parse results of the receiver.\n\nThis is a greedy and blind implementation that tries to consume as much\ninput as possible and that does not consider what comes afterwards.\n\nFor example, the parser [:letter().plus():] accepts any sequence of\nletters and returns a list of the parsed letters.\n","line":"106"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"times1()","name":"times","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"count","name":"count","kind":"param"}],"kind":"method","comment":"\nReturns a parser that accepts the receiver exactly [count] times. The\nresulting parser returns a list of the parse results of the receiver.\n\nFor example, the parser [:letter().times(2):] accepts two letters and\nreturns a list of the two parsed letters.\n","line":"115"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"repeat2()","name":"repeat","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"min","name":"min","kind":"param"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"max","name":"max","kind":"param"}],"kind":"method","comment":"\nReturns a parser that accepts the receiver between [min] and [max] times.\nThe resulting parser returns a list of the parse results of the receiver.\n\nThis is a greedy and blind implementation that tries to consume as much\ninput as possible and that does not consider what comes afterwards.\n\nFor example, the parser [:letter().repeat(2, 4):] accepts a sequence of\ntwo, three, or four letters and returns the accepted letters as a list.\n","line":"127"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"seq1()","name":"seq","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"other","name":"other","kind":"param"}],"kind":"method","comment":"\nReturns a parser that accepts the receiver followed by [other]. The\nresulting parser returns a list of the parse result of the receiver\nfollowed by the parse result of [other]. Calling [SequenceParser.seq]\ncauses the sequences to be concatenated instead of nested.\n\nFor example, the parser [:letter().seq(digit()).seq(letter()):] accepts a\nletter followed by a digit and another letter. The parse result of the\ninput string [:'a1b':] is the list [:['a', '1', 'b']:].\n","line":"139"},{"isOperator":true,"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"&1()","name":"&","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"other","name":"other","kind":"param"}],"kind":"method","comment":"\nConvenience operator returning a parser accepts the receiver followed\nby [other]. See [Parser.seq] for details.\n","line":"145"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"or1()","name":"or","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"other","name":"other","kind":"param"}],"kind":"method","comment":"\nReturns a parser that accepts the receiver or [other]. The resulting\nparser returns the parse result of the receiver, if the receiver fails\nit returns the parse result of [other] (exclusive ordered choice).\n\nFor example, the parser [:letter().or(digit()):] accepts a letter or a\ndigit. An example where the order matters is the following choice between\noverlapping parsers: [:letter().or(char('a')):]. In the example the parser\n[:char('a'):] will never be activated, because the input is always consumed\n[:letter():]. This can be problematic if the author intended to attach a\nproduction action to [:char('a'):].\n","line":"159"},{"isOperator":true,"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"|1()","name":"|","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"other","name":"other","kind":"param"}],"kind":"method","comment":"\nConvenience operator returning a parser accepts the receiver or\n[other]. See [Parser.or] for details.\n","line":"165"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"and0()","name":"and","kind":"method","comment":"\nReturns a parser (logical and-predicate) that succeeds whenever the\nreceiver does, but never consumes input.\n\nFor example, the parser [:char('_').and().seq(identifier):] accepts\nidentifiers that start with an underscore character. Since the predicate\ndoes not consume accepted input, the parser [:identifier:] is given the\nability to process the complete identifier.\n","line":"176"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"not1()","name":"not","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"message","name":"message","kind":"param"}],"kind":"method","comment":"\nReturns a parser (logical not-predicate) that succeeds whenever the\nreceiver fails, but never consumes input.\n\nFor example, the parser [:char('_').not().seq(identifier):] accepts\nidentifiers that do not start with an underscore character. If the parser\n[:char('_'):] accepts the input, the negation and subsequently the\ncomplete parser fails. Otherwise the parser [:identifier:] is given the\nability to process the complete identifier.\n","line":"188"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"neg1()","name":"neg","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"message","name":"message","kind":"param"}],"kind":"method","comment":"\nReturns a parser that consumes any input token (character), but the\nreceiver.\n\nFor example, the parser [:letter().neg():] accepts any input but a letter.\nThe parser fails for inputs like [:'a':] or [:'Z':], but succeeds for\ninput like [:'1':], [:'_':] or [:'$':].\n","line":"198"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"flatten0()","name":"flatten","kind":"method","comment":"\nReturns a parser that discards the result of the receiver, and returns\na sub-string of the consumed elements in the string/list being parsed.\n\nFor example, the parser [:letter().plus().flatten():] returns [:'abc':]\nfor the input [:'abc':]. In contrast, the parser [:letter().plus():] would\nreturn [:['a', 'b', 'c']:] for the same input instead.\n","line":"208"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"token0()","name":"token","kind":"method","comment":"\nReturns a parser that discards the result of the receiver and returns\na [Token]. The token carries information about where the token started and\nstopped in the input stream.\n\nFor example, the parser [:letter().plus().token():] returns the token\n[:Token[start: 0, stop: 3, value: abc]:] for the input [:'abc':].\n","line":"218"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"trim1()","name":"trim","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"isOptional":true,"id":"trimmer","name":"trimmer","kind":"param"}],"kind":"method","comment":"\nReturns a parser that consumes input before and after the receiver. The\noptional argument [trimmer] is a parser that consumes the excess input. By\ndefault [:whitespace():] is used.\n\nFor example, the parser [:letter().plus().trim():] returns [:['a', 'b']:]\nfor the input [:' ab\\n':] and consumes the complete input string.\n","line":"228"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"end1()","name":"end","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isNamed":true,"defaultValue":"'end of input expected'","isOptional":true,"id":"message","name":"message","kind":"param"}],"kind":"method","comment":"\nReturns a parser that succeeds only if the receiver consumes the complete\ninput, otherwise return a failure with the optional [message].\n\nFor example, the parser [:letter().end():] succeeds on the input [:'a':]\nand fails on [:'ab':]. In contrast the parser [:letter():] alone would\nsucceed on both inputs, but not consume everything for the second input.\n","line":"240"},{"returnType":{"name":"SetableParser","refId":"petitparser/SetableParser"},"id":"setable0()","name":"setable","kind":"method","comment":"\nReturns a parser that points to the receiver, but can be changed to point\nto something else at a later point in time.\n\nFor example, the parser [:letter().setable():] behaves exactly the same\nas [:letter():], but it can be replaced with another parser using\n[SetableParser.set].\n","line":"252"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"map1()","name":"map","children":[{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"function","name":"function","kind":"param"}],"kind":"method","comment":"\nReturns a parser that evaluates [function] as action handler on success\nof the receiver.\n\nFor example, the parser [:digit().map((char) => int.parse(char)):] returns\nthe number [:1:] for the input string [:'1':].\n","line":"261"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"pick1()","name":"pick","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"index","name":"index","kind":"param"}],"kind":"method","comment":"\nReturns a parser that transform a successful parse result by returning\nthe element at [index] of a list. A negative index can be used to access\nthe elements from the back of the list.\n\nFor example, the parser [:letter().star().pick(-1):] returns the last\nletter parsed. For the input [:'abc':] it returns [:'c':].\n","line":"271"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"permute1()","name":"permute","children":[{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"int","refId":"dart.core/int"}]},"id":"indexes","name":"indexes","kind":"param"}],"kind":"method","comment":"\nReturns a parser that transforms a successful parse result by returning\nthe permuted elements at [indexes] of a list. Negative indexes can be\nused to access the elements from the back of the list.\n\nFor example, the parser [:letter().star().permute([0, -1]):] returns the\nfirst and last letter parsed. For the input [:'abc':] it returns\n[:['a', 'c']:].\n","line":"286"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"separatedBy3()","name":"separatedBy","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"separator","name":"separator","kind":"param"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isNamed":true,"defaultValue":"true","isOptional":true,"id":"includeSeparators","name":"includeSeparators","kind":"param"},{"ref":{"name":"bool","refId":"dart.core/bool"},"isNamed":true,"defaultValue":"false","isOptional":true,"id":"optionalSeparatorAtEnd","name":"optionalSeparatorAtEnd","kind":"param","line":"310"}],"kind":"method","comment":"\nReturns a parser that consumes the receiver one or more times separated\nby the [separator] parser. The resulting parser returns a flat list of\nthe parse results of the receiver interleaved with the parse result of the\nseparator parser.\n\nIf the optional argument [includeSeparators] is set to [:false:], then the\nseparators are not included in the parse result. If the optional argument\n[optionalSeparatorAtEnd] is set to [:true:] the parser also accepts an\noptional separator at the end.\n\nFor example, the parser [:digit().separatedBy(char('-')):] returns a parser\nthat consumes input like [:'1-2-3':] and returns a list of the elements and\nseparators: [:['1', '-', '2', '-', '3']:].\n","line":"309"},{"returnType":{"name":"void","refId":"void"},"id":"replace2()","name":"replace","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"source","name":"source","kind":"param"},{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"target","name":"target","kind":"param"}],"kind":"method","comment":"\nChanges the receiver by replacing [source] with [target]. Does nothing\nif [source] does not exist in [Parser.children].\n\nThe following example creates a letter parser and then defines a parser\ncalled [:example:] that accepts one or more letters. Eventually the parser\n[:example:] is modified by replacing the [:letter:] parser with a new\nparser that accepts a digit. The resulting [:example:] parser accepts one\nor more digits.\n\n    var letter = letter();\n    var example = letter.plus();\n    example.replace(letter, digit());\n","line":"358"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"Parser","refId":"petitparser/Parser"}]},"id":"children","name":"children","kind":"property","comment":"\nReturns a list of directly referenced parsers.\n\nFor example, [:letter().children:] returns the empty collection [:[]:],\nbecause the letter parser is a primitive or leaf parser that does not\ndepend or call any other parser.\n\nIn contrast, [:letter().or(digit()).children:] returns a collection\ncontaining both the [:letter():] and [:digit():] parser.\n","line":"342"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/parser.dart","kind":"class","comment":"\nAbstract base class of all parsers.\n","line":"8"},{"interfaces":[{"name":"Error","refId":"dart.core/Error"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"isThrowable":true,"id":"ParserError","name":"ParserError","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"id":"toString0()","name":"toString","kind":"method","line":"106"},{"ref":{"name":"Failure","refId":"petitparser/Failure"},"id":"failure","name":"failure","kind":"property","line":"104"},{"isFinal":true,"ref":{"name":"Failure","refId":"petitparser/Failure"},"id":"_failure","name":"_failure","kind":"variable","isPrivate":true,"line":"100"},{"id":"ParserError1()","name":"ParserError","children":[{"initializedField":{"name":"_failure","refId":"petitparser/ParserError/_failure"},"ref":{"name":"Failure","refId":"petitparser/Failure"},"id":"_failure","name":"_failure","kind":"param","isPrivate":true}],"kind":"constructor","line":"102"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/context.dart","kind":"class","comment":"\nAn exception raised in case of a parse error.\n","line":"98"},{"superclass":{"name":"Result","refId":"petitparser/Result"},"id":"Failure","name":"Failure","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"id":"toString0()","name":"toString","kind":"method","line":"91"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"isFailure","name":"isFailure","kind":"property","line":"85"},{"id":"result","name":"result","kind":"property","line":"87"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"message","name":"message","kind":"property","line":"89"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"id":"_message","name":"_message","kind":"variable","isPrivate":true,"line":"81"},{"id":"Failure3()","name":"Failure","children":[{"id":"buffer","name":"buffer","kind":"param"},{"id":"position","name":"position","kind":"param"},{"initializedField":{"name":"_message","refId":"petitparser/Failure/_message"},"ref":{"name":"String","refId":"dart.core/String"},"id":"_message","name":"_message","kind":"param","isPrivate":true}],"kind":"constructor","line":"83"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/context.dart","kind":"class","comment":"\nAn immutable parse result in case of a failed parse.\n","line":"79"},{"superclass":{"name":"Result","refId":"petitparser/Result"},"id":"Success","name":"Success","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"id":"toString0()","name":"toString","kind":"method","line":"72"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"isSuccess","name":"isSuccess","kind":"property","line":"66"},{"id":"result","name":"result","kind":"property","line":"68"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"message","name":"message","kind":"property","line":"70"},{"isFinal":true,"id":"_result","name":"_result","kind":"variable","isPrivate":true,"line":"62"},{"id":"Success3()","name":"Success","children":[{"id":"buffer","name":"buffer","kind":"param"},{"id":"position","name":"position","kind":"param"},{"initializedField":{"name":"_result","refId":"petitparser/Success/_result"},"id":"_result","name":"_result","kind":"param","isPrivate":true}],"kind":"constructor","line":"64"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/context.dart","kind":"class","comment":"\nAn immutable parse result in case of a successful parse.\n","line":"60"},{"superclass":{"name":"Context","refId":"petitparser/Context"},"isAbstract":true,"id":"Result","name":"Result","children":[{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"isSuccess","name":"isSuccess","kind":"property","comment":"Returns [true] if this result indicates a parse success. ","line":"44"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"isFailure","name":"isFailure","kind":"property","comment":"Returns [true] if this result indicates a parse failure. ","line":"47"},{"id":"result","name":"result","kind":"property","comment":"Returns the parse result of the current context. ","line":"50"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"message","name":"message","kind":"property","comment":"Returns the parse message of the current context. ","line":"53"},{"id":"Result2()","name":"Result","children":[{"id":"buffer","name":"buffer","kind":"param"},{"id":"position","name":"position","kind":"param"}],"kind":"constructor","line":"41"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/context.dart","kind":"class","comment":"\nAn immutable parse result.\n","line":"39"},{"superclass":{"name":"Object","refId":"dart.core/Object"},"id":"Context","name":"Context","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"success2()","name":"success","children":[{"id":"result","name":"result","kind":"param"},{"ref":{"name":"int","refId":"dart.core/int"},"isOptional":true,"id":"position","name":"position","kind":"param"}],"kind":"method","comment":"Returns a result indicating a parse success. ","line":"22"},{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"failure2()","name":"failure","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"message","name":"message","kind":"param"},{"ref":{"name":"int","refId":"dart.core/int"},"isOptional":true,"id":"position","name":"position","kind":"param"}],"kind":"method","comment":"Returns a result indicating a parse failure. ","line":"27"},{"returnType":{"name":"String","refId":"dart.core/String"},"id":"toString0()","name":"toString","kind":"method","comment":"Returns a human readable string of the current context ","line":"32"},{"id":"buffer","name":"buffer","kind":"property","comment":"The buffer we are working on. ","line":"16"},{"ref":{"name":"int","refId":"dart.core/int"},"id":"position","name":"position","kind":"property","comment":"The current position in the buffer. ","line":"19"},{"isFinal":true,"id":"_buffer","name":"_buffer","kind":"variable","isPrivate":true,"line":"10"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"id":"_position","name":"_position","kind":"variable","isPrivate":true,"line":"11"},{"id":"Context2()","name":"Context","children":[{"initializedField":{"name":"_buffer","refId":"petitparser/Context/_buffer"},"id":"_buffer","name":"_buffer","kind":"param","isPrivate":true},{"initializedField":{"name":"_position","refId":"petitparser/Context/_position"},"ref":{"name":"int","refId":"dart.core/int"},"id":"_position","name":"_position","kind":"param","isPrivate":true}],"kind":"constructor","line":"13"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/context.dart","kind":"class","comment":"\nAn immutable parse context.\n","line":"8"},{"interfaces":[{"name":"Error","refId":"dart.core/Error"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"isThrowable":true,"id":"RedefinedProductionError","name":"RedefinedProductionError","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"id":"toString0()","name":"toString","kind":"method","line":"243"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"variable","line":"241"},{"id":"RedefinedProductionError1()","name":"RedefinedProductionError","children":[{"initializedField":{"name":"name","refId":"petitparser/RedefinedProductionError/name"},"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"}],"kind":"constructor","line":"242"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/composite.dart","kind":"class","comment":"\nError raised when a production is accidentally redefined.\n","line":"240"},{"interfaces":[{"name":"Error","refId":"dart.core/Error"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"isThrowable":true,"id":"UndefinedProductionError","name":"UndefinedProductionError","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"id":"toString0()","name":"toString","kind":"method","line":"234"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"variable","line":"232"},{"id":"UndefinedProductionError1()","name":"UndefinedProductionError","children":[{"initializedField":{"name":"name","refId":"petitparser/UndefinedProductionError/name"},"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"}],"kind":"constructor","line":"233"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/composite.dart","kind":"class","comment":"\nError raised when an undefined production is accessed.\n","line":"231"},{"interfaces":[{"name":"Error","refId":"dart.core/Error"}],"superclass":{"name":"Object","refId":"dart.core/Object"},"isThrowable":true,"id":"CompletedParserError","name":"CompletedParserError","children":[{"returnType":{"name":"String","refId":"dart.core/String"},"id":"toString0()","name":"toString","kind":"method","line":"225"},{"id":"CompletedParserError0()","name":"CompletedParserError","kind":"constructor","line":"224"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/composite.dart","kind":"class","comment":"\nError raised when somebody tries to modify a [CompositeParser] outside\nthe [CompositeParser.initialize] method.\n","line":"223"},{"superclass":{"name":"CompositeParser","refId":"petitparser/CompositeParser"},"id":"CompositeParser2","name":"CompositeParser2","children":[{"id":"noSuchMethod1()","name":"noSuchMethod","children":[{"ref":{"name":"InvocationMirror","refId":"dart.core/InvocationMirror"},"id":"mirror","name":"mirror","kind":"param"}],"kind":"method","line":"194"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/composite.dart","kind":"class","comment":"\nExperimental helper to compose complex grammars from various primitive\nparsers using variable references.\n\nThe difference of this implementation to [CompositeParser] is that\nsubclasses can define and refer to productions using variables. The\nvaribales themselves are not actually implement anywhere, but their\nbehavior is defined in [noSuchMethod] and mapped to a collection using\nthe methods defined in the superclass.\n\nConsider the following example to parse a list of numbers:\n\n    class NumberListGrammar2 extends CompositeParser2 {\n      void initialize() {\n        element = digit().plus().flatten();\n        list = element.separatedBy(char(',')));\n        start = list.end();\n      }\n    }\n\nProduction actions can be attached in subclasses by calling the production,\nas in the following example:\n\n    class NumberListParser2 extends NumberListGrammar2 {\n      void initialize() {\n        element((value) => int.parse(value));\n      }\n    }\n\nCreavats: The Dart editor currently shows an abundance of spurious warnings,\nas all productions are undefined from the perspective of the analyzer. Pay\nattention with production names that conflict with methods defined in the\nsuperclasses. The generated JavaScript code is noticably bigger, due to the\nuse of [noSuchMethod]. The resulting parsers identical and parse-speed is\nthe same, onlyt he construction of the parser itself is slightly more\nexpensive.\n","line":"192"},{"superclass":{"name":"_SetableParser","refId":"petitparser/_SetableParser"},"isAbstract":true,"id":"CompositeParser","name":"CompositeParser","children":[{"returnType":{"name":"void","refId":"void"},"id":"initialize0()","name":"initialize","kind":"method","comment":"\nInitializes the composite grammar.\n","line":"52"},{"returnType":{"name":"void","refId":"void"},"id":"_complete0()","name":"_complete","kind":"method","comment":"\nInternal method to complete the grammar.\n","isPrivate":true,"line":"57"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"ref1()","name":"ref","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"}],"kind":"method","comment":"\nReturns a reference to a production with a [name].\n\nThis method works during initialization and after completion of the\ninitialization. During the initialization it returns delegate parsers\nthat are eventually replaced by the real parsers. Afterwards it\nreturns the defined parser (mostly useful for testing).\n","line":"78"},{"isOperator":true,"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"[]1()","name":"[]","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"}],"kind":"method","comment":"\nConvenience operator returning a reference to a production with\na [name]. See [CompositeParser.ref] for details.\n","line":"96"},{"returnType":{"name":"void","refId":"void"},"id":"def2()","name":"def","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"},{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"parser","name":"parser","kind":"param"}],"kind":"method","comment":"\nDefines a production with a [name] and a [parser]. Only call this method\nfrom [initialize].\n\nThe following example defines a list production that consumes\nseveral elements separated by a comma.\n\n    def('list', ref('element').separatedBy(char(',')));\n","line":"107"},{"returnType":{"name":"void","refId":"void"},"id":"redef2()","name":"redef","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"},{"id":"replacement","name":"replacement","kind":"param"}],"kind":"method","comment":"\nRedefinies an existing production with a [name] and a [replacement]\nparser or function producing a new parser. The code raises an\n[UndefinedProductionError] if [name] is an undefined production. Only call\nthis method from [initialize].\n\nThe following example redefines the previously defined list production\nby making it optional:\n\n    redef('list', (parser) => parser.optional());\n","line":"128"},{"returnType":{"name":"void","refId":"void"},"id":"action2()","name":"action","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"name","name":"name","kind":"param"},{"ref":{"name":"Function","refId":"dart.core/Function"},"id":"function","name":"function","children":[{"id":"Function","name":"Function","children":[{"id":"Dynamic","name":"Dynamic","uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/composite.dart","kind":"param","line":"149"}],"uri":"file:///usr/local/Cellar/dart-editor/21094/dart-sdk//lib/core/function.dart","kind":"functiontype","line":"13"}],"kind":"param"}],"kind":"method","comment":"\nAttaches an action [function] to an existing production [name]. The code\nraises an [UndefinedProductionError] if [name] is an undefined production.\nOnly call this method from [initialize].\n\nThe following example attaches an action returning the size of list of\nthe previously defined list production:\n\n    action('list', (list) => list.length);\n","line":"149"},{"ref":{"name":"bool","refId":"dart.core/bool"},"id":"_completed","name":"_completed","kind":"variable","isPrivate":true,"line":"40"},{"isFinal":true,"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"},{"name":"Parser","refId":"petitparser/Parser"}]},"id":"_defined","name":"_defined","kind":"variable","isPrivate":true,"line":"41"},{"isFinal":true,"ref":{"name":"Map","refId":"dart.core/Map","arguments":[{"name":"String","refId":"dart.core/String"},{"name":"SetableParser","refId":"petitparser/SetableParser"}]},"id":"_undefined","name":"_undefined","kind":"variable","isPrivate":true,"line":"42"},{"id":"CompositeParser0()","name":"CompositeParser","kind":"constructor","line":"44"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/composite.dart","kind":"class","comment":"\nHelper to compose complex grammars from various primitive parsers.\n\nTo create a new composite grammar subclass [CompositeParser]. Override\nthe method [initialize] and for every production call [def] giving the\nproduction a name. The start production must be named 'start'. To refer\nto other produtions (forward and backward) use [ref].\n\nConsider the following example to parse a list of numbers:\n\n    class NumberListGrammar extends CompositeParser {\n      void initialize() {\n        def('element', digit().plus().flatten());\n        def('list', ref('element').separatedBy(char(',')));\n        def('start', ref('list').end());\n      }\n    }\n\nYou might want to create future subclasses of your composite grammar\nto redefine the grammar or attach custom actions. In such a subclass\noverride the method [initialize] again and call super. Then use\n[redef] to redefine an existing production, and [action] to attach an\naction to an existing production.\n\nConsider the following example that attaches a production action and\nconverts the digits to actual numbers:\n\n    class NumberListParser extends NumberListGrammar {\n      void initialize() {\n        action('element', (value) => int.parse(value));\n      }\n    }\n","line":"38"},{"superclass":{"name":"_ListParser","refId":"petitparser/_ListParser"},"id":"_SequenceParser","name":"_SequenceParser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","isPrivate":true,"line":"198"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"seq1()","name":"seq","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"other","name":"other","kind":"param"}],"kind":"method","line":"212"},{"id":"_SequenceParser1()","name":"_SequenceParser","children":[{"id":"_parsers","name":"_parsers","kind":"param","isPrivate":true}],"kind":"constructor","line":"196"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/combinators.dart","kind":"class","comment":"\nA parser that parses a sequence of parsers.\n","isPrivate":true,"line":"194"},{"superclass":{"name":"_ListParser","refId":"petitparser/_ListParser"},"id":"_ChoiceParser","name":"_ChoiceParser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","isPrivate":true,"line":"172"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"or1()","name":"or","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"other","name":"other","kind":"param"}],"kind":"method","line":"183"},{"id":"_ChoiceParser1()","name":"_ChoiceParser","children":[{"id":"parsers","name":"parsers","kind":"param"}],"kind":"constructor","line":"170"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/combinators.dart","kind":"class","comment":"\nA parser that uses the first parser that succeeds.\n","isPrivate":true,"line":"168"},{"superclass":{"name":"Parser","refId":"petitparser/Parser"},"isAbstract":true,"id":"_ListParser","name":"_ListParser","children":[{"returnType":{"name":"void","refId":"void"},"id":"replace2()","name":"replace","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"source","name":"source","kind":"param"},{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"target","name":"target","kind":"param"}],"kind":"method","line":"154"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"Parser","refId":"petitparser/Parser"}]},"id":"children","name":"children","kind":"property","line":"152"},{"isFinal":true,"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"Parser","refId":"petitparser/Parser"}]},"id":"_parsers","name":"_parsers","kind":"variable","isPrivate":true,"line":"148"},{"id":"_ListParser1()","name":"_ListParser","children":[{"initializedField":{"name":"_parsers","refId":"petitparser/_ListParser/_parsers"},"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"Parser","refId":"petitparser/Parser"}]},"id":"_parsers","name":"_parsers","kind":"param","isPrivate":true}],"kind":"constructor","line":"150"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/combinators.dart","kind":"class","comment":"\nAbstract parser that parses a list of things in some way.\n","isPrivate":true,"line":"146"},{"superclass":{"name":"_DelegateParser","refId":"petitparser/_DelegateParser"},"id":"_RepeatingParser","name":"_RepeatingParser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","isPrivate":true,"line":"119"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"id":"_min","name":"_min","kind":"variable","isPrivate":true,"line":"114"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"id":"_max","name":"_max","kind":"variable","isPrivate":true,"line":"115"},{"id":"_RepeatingParser3()","name":"_RepeatingParser","children":[{"id":"parser","name":"parser","kind":"param"},{"initializedField":{"name":"_min","refId":"petitparser/_RepeatingParser/_min"},"ref":{"name":"int","refId":"dart.core/int"},"id":"_min","name":"_min","kind":"param","isPrivate":true},{"initializedField":{"name":"_max","refId":"petitparser/_RepeatingParser/_max"},"ref":{"name":"int","refId":"dart.core/int"},"id":"_max","name":"_max","kind":"param","isPrivate":true}],"kind":"constructor","line":"117"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/combinators.dart","kind":"class","comment":"\nA parser that repeatedly parses a sequence of parsers.\n","isPrivate":true,"line":"112"},{"superclass":{"name":"_DelegateParser","refId":"petitparser/_DelegateParser"},"id":"_OptionalParser","name":"_OptionalParser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","isPrivate":true,"line":"98"},{"isFinal":true,"id":"_otherwise","name":"_otherwise","kind":"variable","isPrivate":true,"line":"94"},{"id":"_OptionalParser2()","name":"_OptionalParser","children":[{"id":"parser","name":"parser","kind":"param"},{"initializedField":{"name":"_otherwise","refId":"petitparser/_OptionalParser/_otherwise"},"id":"_otherwise","name":"_otherwise","kind":"param","isPrivate":true}],"kind":"constructor","line":"96"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/combinators.dart","kind":"class","comment":"\nA parser that optionally parsers its delegate, or answers nil.\n","isPrivate":true,"line":"92"},{"superclass":{"name":"_DelegateParser","refId":"petitparser/_DelegateParser"},"id":"_NotParser","name":"_NotParser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","isPrivate":true,"line":"78"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"id":"_message","name":"_message","kind":"variable","isPrivate":true,"line":"74"},{"id":"_NotParser2()","name":"_NotParser","children":[{"id":"parser","name":"parser","kind":"param"},{"initializedField":{"name":"_message","refId":"petitparser/_NotParser/_message"},"ref":{"name":"String","refId":"dart.core/String"},"id":"_message","name":"_message","kind":"param","isPrivate":true}],"kind":"constructor","line":"76"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/combinators.dart","kind":"class","comment":"\nThe not-predicate, a parser that succeeds whenever its delegate does not,\nbut consumes no input [Parr 1994, 1995].\n","isPrivate":true,"line":"72"},{"superclass":{"name":"_DelegateParser","refId":"petitparser/_DelegateParser"},"id":"_AndParser","name":"_AndParser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","isPrivate":true,"line":"57"},{"id":"_AndParser1()","name":"_AndParser","children":[{"id":"parser","name":"parser","kind":"param"}],"kind":"constructor","line":"55"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/combinators.dart","kind":"class","comment":"\nThe and-predicate, a parser that succeeds whenever its delegate does, but\ndoes not consume the input stream [Parr 1994, 1995].\n","isPrivate":true,"line":"53"},{"superclass":{"name":"_DelegateParser","refId":"petitparser/_DelegateParser"},"id":"_EndOfInputParser","name":"_EndOfInputParser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","isPrivate":true,"line":"39"},{"isFinal":true,"ref":{"name":"String","refId":"dart.core/String"},"id":"_message","name":"_message","kind":"variable","isPrivate":true,"line":"35"},{"id":"_EndOfInputParser2()","name":"_EndOfInputParser","children":[{"id":"parser","name":"parser","kind":"param"},{"initializedField":{"name":"_message","refId":"petitparser/_EndOfInputParser/_message"},"ref":{"name":"String","refId":"dart.core/String"},"id":"_message","name":"_message","kind":"param","isPrivate":true}],"kind":"constructor","line":"37"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/combinators.dart","kind":"class","comment":"\nA parser that succeeds only at the end of the input.\n","isPrivate":true,"line":"33"},{"superclass":{"name":"Parser","refId":"petitparser/Parser"},"id":"_DelegateParser","name":"_DelegateParser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","isPrivate":true,"line":"15"},{"returnType":{"name":"void","refId":"void"},"id":"replace2()","name":"replace","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"source","name":"source","kind":"param"},{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"target","name":"target","kind":"param"}],"kind":"method","line":"21"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"Parser","refId":"petitparser/Parser"}]},"id":"children","name":"children","kind":"property","line":"19"},{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"_delegate","name":"_delegate","kind":"variable","isPrivate":true,"line":"11"},{"id":"_DelegateParser1()","name":"_DelegateParser","children":[{"initializedField":{"name":"_delegate","refId":"petitparser/_DelegateParser/_delegate"},"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"_delegate","name":"_delegate","kind":"param","isPrivate":true}],"kind":"constructor","line":"13"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/combinators.dart","kind":"class","comment":"\nA parser that delegates to another one. Normally users do not need to\ndirectly use a delegate parser.\n","isPrivate":true,"line":"9"},{"superclass":{"name":"_CharacterParser","refId":"petitparser/_CharacterParser"},"id":"_WordParser","name":"_WordParser","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"_match1()","name":"_match","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"value","name":"value","kind":"param"}],"kind":"method","isPrivate":true,"line":"195"},{"id":"_WordParser1()","name":"_WordParser","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"message","name":"message","kind":"param"}],"kind":"constructor","line":"194"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"class","isPrivate":true,"line":"193"},{"superclass":{"name":"_CharacterParser","refId":"petitparser/_CharacterParser"},"id":"_WhitespaceParser","name":"_WhitespaceParser","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"_match1()","name":"_match","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"value","name":"value","kind":"param"}],"kind":"method","isPrivate":true,"line":"183"},{"id":"_WhitespaceParser1()","name":"_WhitespaceParser","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"message","name":"message","kind":"param"}],"kind":"constructor","line":"182"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"class","isPrivate":true,"line":"181"},{"superclass":{"name":"_CharacterParser","refId":"petitparser/_CharacterParser"},"id":"_UppercaseParser","name":"_UppercaseParser","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"_match1()","name":"_match","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"value","name":"value","kind":"param"}],"kind":"method","isPrivate":true,"line":"173"},{"id":"_UppercaseParser1()","name":"_UppercaseParser","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"message","name":"message","kind":"param"}],"kind":"constructor","line":"172"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"class","isPrivate":true,"line":"171"},{"superclass":{"name":"_CharacterParser","refId":"petitparser/_CharacterParser"},"id":"_RangeParser","name":"_RangeParser","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"_match1()","name":"_match","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"value","name":"value","kind":"param"}],"kind":"method","isPrivate":true,"line":"163"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"id":"_start","name":"_start","kind":"variable","isPrivate":true,"line":"160"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"id":"_stop","name":"_stop","kind":"variable","isPrivate":true,"line":"161"},{"id":"_RangeParser3()","name":"_RangeParser","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"message","name":"message","kind":"param"},{"initializedField":{"name":"_start","refId":"petitparser/_RangeParser/_start"},"ref":{"name":"int","refId":"dart.core/int"},"id":"_start","name":"_start","kind":"param","isPrivate":true},{"initializedField":{"name":"_stop","refId":"petitparser/_RangeParser/_stop"},"ref":{"name":"int","refId":"dart.core/int"},"id":"_stop","name":"_stop","kind":"param","isPrivate":true}],"kind":"constructor","line":"162"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"class","isPrivate":true,"line":"159"},{"superclass":{"name":"_CharacterParser","refId":"petitparser/_CharacterParser"},"id":"_LowercaseParser","name":"_LowercaseParser","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"_match1()","name":"_match","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"value","name":"value","kind":"param"}],"kind":"method","isPrivate":true,"line":"128"},{"id":"_LowercaseParser1()","name":"_LowercaseParser","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"message","name":"message","kind":"param"}],"kind":"constructor","line":"127"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"class","isPrivate":true,"line":"126"},{"superclass":{"name":"_CharacterParser","refId":"petitparser/_CharacterParser"},"id":"_LetterParser","name":"_LetterParser","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"_match1()","name":"_match","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"value","name":"value","kind":"param"}],"kind":"method","isPrivate":true,"line":"118"},{"id":"_LetterParser1()","name":"_LetterParser","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"message","name":"message","kind":"param"}],"kind":"constructor","line":"117"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"class","isPrivate":true,"line":"116"},{"superclass":{"name":"_CharacterParser","refId":"petitparser/_CharacterParser"},"id":"_DigitParser","name":"_DigitParser","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"_match1()","name":"_match","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"value","name":"value","kind":"param"}],"kind":"method","isPrivate":true,"line":"108"},{"id":"_DigitParser1()","name":"_DigitParser","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"message","name":"message","kind":"param"}],"kind":"constructor","line":"107"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"class","isPrivate":true,"line":"106"},{"superclass":{"name":"_CharacterParser","refId":"petitparser/_CharacterParser"},"id":"_CharParser","name":"_CharParser","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"_match1()","name":"_match","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"value","name":"value","kind":"param"}],"kind":"method","isPrivate":true,"line":"98"},{"isFinal":true,"ref":{"name":"int","refId":"dart.core/int"},"id":"_char","name":"_char","kind":"variable","isPrivate":true,"line":"96"},{"id":"_CharParser2()","name":"_CharParser","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"message","name":"message","kind":"param"},{"initializedField":{"name":"_char","refId":"petitparser/_CharParser/_char"},"ref":{"name":"int","refId":"dart.core/int"},"id":"_char","name":"_char","kind":"param","isPrivate":true}],"kind":"constructor","line":"97"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"class","isPrivate":true,"line":"95"},{"superclass":{"name":"_CharacterParser","refId":"petitparser/_CharacterParser"},"id":"_BinarySearchCharacterParser","name":"_BinarySearchCharacterParser","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"_match1()","name":"_match","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"value","name":"value","kind":"param"}],"kind":"method","isPrivate":true,"line":"73"},{"isFinal":true,"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"int","refId":"dart.core/int"}]},"id":"_codes","name":"_codes","kind":"variable","isPrivate":true,"line":"71"},{"id":"_BinarySearchCharacterParser2()","name":"_BinarySearchCharacterParser","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"message","name":"message","kind":"param"},{"initializedField":{"name":"_codes","refId":"petitparser/_BinarySearchCharacterParser/_codes"},"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"int","refId":"dart.core/int"}]},"id":"_codes","name":"_codes","kind":"param","isPrivate":true}],"kind":"constructor","line":"72"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"class","comment":"Internal parser class that does a binary search. ","isPrivate":true,"line":"70"},{"superclass":{"name":"_CharacterParser","refId":"petitparser/_CharacterParser"},"id":"_AlternativeCharacterParser","name":"_AlternativeCharacterParser","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"_match1()","name":"_match","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"value","name":"value","kind":"param"}],"kind":"method","isPrivate":true,"line":"50"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"or1()","name":"or","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"other","name":"other","kind":"param"}],"kind":"method","line":"58"},{"isFinal":true,"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"_CharacterParser","refId":"petitparser/_CharacterParser"}]},"id":"_parsers","name":"_parsers","kind":"variable","isPrivate":true,"line":"46"},{"id":"_AlternativeCharacterParser1()","name":"_AlternativeCharacterParser","children":[{"id":"parsers","name":"parsers","kind":"param"}],"kind":"constructor","line":"47"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"class","comment":"Internal parser class for alternative character classes. ","isPrivate":true,"line":"45"},{"superclass":{"name":"_CharacterParser","refId":"petitparser/_CharacterParser"},"id":"_NegatedCharacterParser","name":"_NegatedCharacterParser","children":[{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"_match1()","name":"_match","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"value","name":"value","kind":"param"}],"kind":"method","isPrivate":true,"line":"40"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"neg1()","name":"neg","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"message","name":"message","kind":"param"}],"kind":"method","line":"41"},{"isFinal":true,"ref":{"name":"_CharacterParser","refId":"petitparser/_CharacterParser"},"id":"_parser","name":"_parser","kind":"variable","isPrivate":true,"line":"38"},{"id":"_NegatedCharacterParser2()","name":"_NegatedCharacterParser","children":[{"ref":{"name":"String","refId":"dart.core/String"},"id":"message","name":"message","kind":"param"},{"initializedField":{"name":"_parser","refId":"petitparser/_NegatedCharacterParser/_parser"},"ref":{"name":"_CharacterParser","refId":"petitparser/_CharacterParser"},"id":"_parser","name":"_parser","kind":"param","isPrivate":true}],"kind":"constructor","line":"39"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"class","comment":"Internal parser class for negated character classes. ","isPrivate":true,"line":"37"},{"superclass":{"name":"Parser","refId":"petitparser/Parser"},"isAbstract":true,"id":"_CharacterParser","name":"_CharacterParser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","isPrivate":true,"line":"21"},{"returnType":{"name":"bool","refId":"dart.core/bool"},"id":"_match1()","name":"_match","children":[{"ref":{"name":"int","refId":"dart.core/int"},"id":"value","name":"value","kind":"param"}],"kind":"method","isPrivate":true,"line":"31"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"or1()","name":"or","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"other","name":"other","kind":"param"}],"kind":"method","line":"32"},{"returnType":{"name":"Parser","refId":"petitparser/Parser"},"id":"neg1()","name":"neg","children":[{"ref":{"name":"String","refId":"dart.core/String"},"isOptional":true,"id":"message","name":"message","kind":"param"}],"kind":"method","line":"33"},{"ref":{"name":"String","refId":"dart.core/String"},"id":"_message","name":"_message","kind":"variable","isPrivate":true,"line":"19"},{"id":"_CharacterParser1()","name":"_CharacterParser","children":[{"initializedField":{"name":"_message","refId":"petitparser/_CharacterParser/_message"},"ref":{"name":"String","refId":"dart.core/String"},"id":"_message","name":"_message","kind":"param","isPrivate":true}],"kind":"constructor","line":"20"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/characters.dart","kind":"class","comment":"Internal abstract parser class for character classes. ","isPrivate":true,"line":"18"},{"superclass":{"name":"_DelegateParser","refId":"petitparser/_DelegateParser"},"id":"_TokenParser","name":"_TokenParser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","isPrivate":true,"line":"91"},{"id":"_TokenParser1()","name":"_TokenParser","children":[{"id":"parser","name":"parser","kind":"param"}],"kind":"constructor","line":"89"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/actions.dart","kind":"class","comment":"\nA parser that answers a token of the result its delegate parses.\n","isPrivate":true,"line":"87"},{"superclass":{"name":"_DelegateParser","refId":"petitparser/_DelegateParser"},"id":"_FlattenParser","name":"_FlattenParser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","isPrivate":true,"line":"70"},{"id":"_FlattenParser1()","name":"_FlattenParser","children":[{"id":"parser","name":"parser","kind":"param"}],"kind":"constructor","line":"68"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/actions.dart","kind":"class","comment":"\nA parser that answers a substring or sublist of the range its delegate\nparses.\n","isPrivate":true,"line":"66"},{"superclass":{"name":"_DelegateParser","refId":"petitparser/_DelegateParser"},"id":"_TrimmingParser","name":"_TrimmingParser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","isPrivate":true,"line":"35"},{"returnType":{"name":"void","refId":"void"},"id":"replace2()","name":"replace","children":[{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"source","name":"source","kind":"param"},{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"target","name":"target","kind":"param"}],"kind":"method","line":"53"},{"ref":{"name":"List","refId":"dart.core/List","arguments":[{"name":"Parser","refId":"petitparser/Parser"}]},"id":"children","name":"children","kind":"property","line":"51"},{"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"_trimmer","name":"_trimmer","kind":"variable","isPrivate":true,"line":"31"},{"id":"_TrimmingParser2()","name":"_TrimmingParser","children":[{"id":"parser","name":"parser","kind":"param"},{"initializedField":{"name":"_trimmer","refId":"petitparser/_TrimmingParser/_trimmer"},"ref":{"name":"Parser","refId":"petitparser/Parser"},"id":"_trimmer","name":"_trimmer","kind":"param","isPrivate":true}],"kind":"constructor","line":"33"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/actions.dart","kind":"class","comment":"\nA parser that silently consumes input of a parser around its delegate.\n","isPrivate":true,"line":"29"},{"superclass":{"name":"_DelegateParser","refId":"petitparser/_DelegateParser"},"id":"_ActionParser","name":"_ActionParser","children":[{"returnType":{"name":"Result","refId":"petitparser/Result"},"id":"_parse1()","name":"_parse","children":[{"ref":{"name":"Context","refId":"petitparser/Context"},"id":"context","name":"context","kind":"param"}],"kind":"method","isPrivate":true,"line":"15"},{"isFinal":true,"ref":{"name":"Function","refId":"dart.core/Function"},"id":"_function","name":"_function","kind":"variable","isPrivate":true,"line":"11"},{"id":"_ActionParser2()","name":"_ActionParser","children":[{"id":"parser","name":"parser","kind":"param"},{"initializedField":{"name":"_function","refId":"petitparser/_ActionParser/_function"},"ref":{"name":"Function","refId":"dart.core/Function"},"id":"_function","name":"_function","kind":"param","isPrivate":true}],"kind":"constructor","line":"13"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/src/core/actions.dart","kind":"class","comment":"\nA parser that performs a transformation with a given function on the\nsuccessful parse result of the delegate.\n","isPrivate":true,"line":"9"}],"uri":"file:///Users/kevin/source/github/petitParser.dart/lib/petitparser.dart","kind":"library","comment":"\n# Writing a Simple Grammar\n\nWriting grammars with PetitParser is simple as writing Dart code. For\nexample, to write a grammar that can parse identifiers that start with\na letter followed by zero or more letter or digits is defined as follows:\n\n    Parser id = letter().seq(letter().or(digit()).star());\n\nIf you look at the object [:id:] in the debugger, you'll notice\nthat the code above buils a tree of parser objects:\n\n- Sequence: This parser accepts a sequence of parsers.\n- - Predicate: This parser accepts a single letter.\n- - Repeater: This parser accepts zero or more times another parser.\n- - - Choice: This parser accepts a single word character.\n- - - - Predicate: This parser accepts a single letter.\n- - - - Predicate: This parser accepts a single digit.\n\n# Parsing Some Input\n\nTo actually parse a [String] (or [List]) we can use the method\n[Parser.parse]:\n\n    Result id1 = id.parse('yeah');\n    Result id2 = id.parse('f12');\n\nThe method [Parser.parse] returns a parse [Result], which is either an\ninstance of [Success] or [Failure]. In both examples above we are\nsuccessful and can retrieve the parse result using [Success.result]:\n\n    print(id1.result);                  // ['y', ['e', 'a', 'h']]\n    print(id2.result);                  // ['f', ['1', '2']]\n\nWhile it seems odd to get these nested arrays with characters as a return\nvalue, this is the default decomposition of the input into a parse tree.\nWe'll see in a while how that can be customized.\n\nIf we try to parse something invalid we get an instance of [Failure] as\nan answer and we can retrieve a descriptive error message using\n[Failure.message]:\n\n    Result id3 = id.parse('123');\n    print(id3.message);                // 'letter expected'\n    print(id3.position);               // 0\n\nTrying to retrieve the parse result by calling [Failure.result] would throw\nthe exception [UnsupportedError]. [Result.isSuccess] and [Result.isFailure]\ncan be used to decide if the parse was successful.\n\nIf you are only interested if a given string matches or not you can use the\nhelper method [Parser.accept]:\n\n    print(id.accept('foo'));            // true\n    print(id.accept('123'));            // false\n\n# Different Kinds of Parsers\n\nPetitParser provide a large set of ready-made parser that you can compose\nto consume and transform arbitrarily complex languages. The terminal parsers\nare the most simple ones. We've already seen a few of those:\n\n  * [:char('a'):] parses the character *a*.\n  * [:string('abc'):] parses the string *abc*.\n  * [:any():] parses any character.\n  * [:digit():] parses any digit from *0* to *9*.\n  * [:letter():] parses any letter from *a* to *z* and *A* to *Z*.\n  * [:word():] parses any letter or digit.\n\nSo instead of using the letter and digit predicate, we could have written\nour identifier parser like this:\n\n    var id = letter().seq(word().star());\n\nThe next set of parsers are used to combine other parsers together:\n\n  * [:p1.seq(p2):] and [:p1 & p2:] parse *p1* followed by *p2* (sequence).\n  * [:p1.or(p2):] and [:p1 | p2:] parse *p1*, if that doesn't work parses *p2* (ordered choice).\n  * [:p.star():] parses *p* zero or more times.\n  * [:p.plus():] parses *p* one or more times.\n  * [:p.optional():] parses *p*, if possible.\n  * [:p.and():] parses *p*, but does not consume its input.\n  * [:p.not():] parses *p* and succeed when p fails, but does not consume its input.\n  * [:p.end():] parses *p* and succeed at the end of the input.\n\nTo attach an action or transformation to a parser we can use the following\nmethods:\n\n  * [:p.map((value) => ...):] performs the transformation given the function.\n  * [:p.pick(n):] returns the *n*-th element of the list *p* returns.\n  * [:p.flatten():] creates a string from the result of *p*.\n  * [:p.token():] creates a token from the result of *p*.\n  * [:p.trim():] trims whitespaces before and after *p*.\n\nTo return a string of the parsed identifier, we can modify our parser like\nthis:\n\n    var id = letter().seq(word().star()).flatten();\n\nTo conveniently find all matches in a given input string you can use\n[Parser.matchesSkipping]:\n\n    var matches = id.matchesSkipping('foo 123 bar4');\n    print(matches);                    // ['foo', 'bar4']\n\n\nThese are the basic elements to build parsers. There are a few more well\ndocumented and tested factory methods in the [Parser] class. If you want\nbrowse their documentation and tests.\n\n# Writing a More Complicated Grammar\n\nNow we are able to write a more complicated grammar for evaluating simple\narithmetic expressions. Within a file we start with the grammar for a\nnumber (actually an integer):\n\n    var number = digit().plus().flatten().trim().map(int.parse);\n\nThen we define the productions for addition and multiplication in order of\nprecedence. Note that we instantiate the productions with undefined parsers\nupfront, because they recursively refer to each other. Later on we can\nresolve this recursion by setting their reference:\n\n    var term = undefined();\n    var prod = undefined();\n    var prim = undefined();\n\n    term.set(prod.seq(char('+').trim()).seq(term).map((values) {\n      return values[0] + values[2];\n    }).or(prod));\n    prod.set(prim.seq(char('*').trim()).seq(prod).map((values) {\n      return values[0] * values[2];\n    }).or(prim));\n    prim.set(char('(').trim().seq(term).seq(char(')'.trim())).map((values) {\n      return values[1];\n    }).or(number));\n\nTo make sure that our parser consumes all input we wrap it with the [:end():]\nparser into the start production:\n\n    var start = term.end();\n\nThat's it, now we can test our parser and evaluator:\n\n    print(start.parse('1 + 2 * 3').result);       // 7\n    print(start.parse('(1 + 2) * 3').result);     // 9\n\nAs an exercise we could extend the parser to also accept negative numbers\nand floating point numbers, not only integers. Furthermore it would be\nuseful to support subtraction and division as well. All these features\ncan be added with a few lines of PetitParser code.\n","line":"155"}