        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>DartGrammar class / dart Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="dart" data-type="DartGrammar">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../dart.html">dart</a> &rsaquo; <a href="../dart/DartGrammar.html">DartGrammar</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>DartGrammar</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>Dart grammar definition.</p>
<pre class="source">
class DartGrammar extends CompositeParser2 {

 void initialize() {
   _whitespace();
   _lexemes();
   _keywords();
   _types();
   _declarations();
   _expressions();
   _statements();
   _libraries();
 }

 /** Defines the whitespace and comments. */
 void _whitespace() {
   def('whitespace', whitespace()
     .or(ref('singe line comment'))
     .or(ref('multi line comment')));
   def('singe line comment', string('//')
     .seq(Token.newlineParser().neg().star()));
   def('multi line comment', string('/*')
     .seq(string('*/').neg().star())
     .seq(string('*/')));
 }

 /** Defines a token parser that consumes whitespace. */
 Parser _token(String name) {
   var parser = name.length == 1 ? char(name) : string(name);
   return parser.token().trim(ref('whitespace'));
 }

 void _lexemes() {
   backSlash = _token('\\');
   colon = _token(':');
   comma = _token(',');
   dollar = _token('\$');
   dot = _token('.');
   doubleQuote = _token('"');
   equalSign = _token('=');
   lparen = _token('(');
   minus = _token('-');
   pluz = _token('+');
   rparen = _token(')');
   semicolon = _token(';');
   singleQuote = _token("'");
   tripleDoubleQuote = _token('"""');
   tripleSingleQuote = _token("'''");

   DIGIT = range('0', '9');
   LETTER = letter();
   HEX_DIGIT =
       range('a','f')
       | range('A','F')
       | DIGIT
       ;

   HEX_NUMBER =
       _token('0x') &amp; HEX_DIGIT.plus()
   | _token('0X') &amp; HEX_DIGIT.plus()
   ;

   EXPONENT =
     (_token('e') | _token('E')) &amp; (pluz | minus).optional() &amp; DIGIT.plus()
   ;

   NUMBER =
     DIGIT.plus() &amp; (dot &amp; DIGIT.plus()).optional() &amp; EXPONENT.optional()
   |  dot &amp; DIGIT.plus() &amp; EXPONENT.optional()
   ;

   HEX_DIGIT_SEQUENCE =
     HEX_DIGIT &amp; HEX_DIGIT.optional() &amp; HEX_DIGIT.optional() &amp; HEX_DIGIT.optional() &amp; HEX_DIGIT.optional() &amp; HEX_DIGIT.optional();

   ESCAPE_SEQUENCE =
       _token('\n')
     | _token('\r')
     | _token('\f')
     | _token('\b')
     | _token('\t')
     | _token('\v')
     | _token('\\x') &amp; HEX_DIGIT &amp; HEX_DIGIT
     | _token('\\u') &amp; HEX_DIGIT &amp; HEX_DIGIT &amp; HEX_DIGIT &amp; HEX_DIGIT
     | _token('\\u{') &amp; HEX_DIGIT_SEQUENCE &amp; _token('}')
     ;

 }

 void _keywords() {
   ASSERT = _token('assert');
   BREAK = _token('break');
   CASE = _token('case');
   CATCH = _token('catch');
   CLASS = _token('class');
   CONST = _token('const');
   CONTINUE = _token('continue');
   DEFAULT = _token('default');
   DO = _token('do');
   ELSE = _token('else');
   EXTENDS = _token('extends');
   FALSE = _token('false');
   FINAL = _token('final');
   FINALLY = _token('finally');
   FOR = _token('for');
   IF = _token('if');
   IN = _token('in');
   IS = _token('is');
   NEW = _token('new');
   NULL = _token('null');
   RETHROW = _token('rethrow');
   RETURN = _token('return');
   SUPER = _token('super');
   SWITCH = _token('switch');
   THIS = _token('this');
   THROW = _token('throw');
   TRUE = _token('true');
   TRY = _token('try');
   VAR = _token('var');
   VOID = _token('void');
   WHILE = _token('while');
   WITH = _token('with');

   // built-in identifiers

   ABSTRACT = _token('abstract');
   AS = _token('as');
   DYNAMIC = _token('dynamic');
   EXPORT = _token('export');
   EXTERNAL = _token('external');
   FACTORY = _token('factory');
   GET = _token('get');
   IMPLEMENTS = _token('implements');
   IMPORT = _token('import');
   LIBRARY = _token('library');
   OPERATOR = _token('operator');
   PART = _token('part');
   SET = _token('set');
   STATIC = _token('static');
   TYPEDEF = _token('typedef');

   // special cases
   HIDE = _token('hide');
   SHOW = _token('show');
   OF = _token('of');
   ON = _token('on');

 }

 void _types() {

   typeArguments = _token('&lt;') &amp; typeList &amp; _token('&gt;');
   typeName = qualified;
   type = typeName &amp; typeArguments.optional();
   typeList = type.separatedBy(comma).optional();
   functionPrefix = returnType.optional() &amp; identifier;
   functionTypeAlias = functionPrefix &amp; typeParameters.optional() &amp; formalParameterList &amp; semicolon;
   typeAliasBody = identifier &amp; typeParameters.optional() &amp; equalSign &amp; ABSTRACT.optional() &amp; mixinApplication | functionTypeAlias;
   typeAlias = metadata &amp; TYPEDEF &amp; typeAliasBody;

 }

 void _declarations() {
   metadata = (_token('@') &amp; qualified &amp; (dot &amp; identifier).optional() &amp; arguments.optional()).star();

   typeParameter = metadata &amp; identifier &amp; (EXTENDS &amp; type).optional();
   typeParameters = _token('&lt;') &amp; typeParameter.separatedBy(comma) &amp; _token('&gt;');

   returnType =
     VOID
     | type
   ;

   varOrType =
       VAR
       | type
       ;

   finalConstVarOrType =
     FINAL &amp; type.optional()
     | CONST &amp; type.optional()
     | varOrType
   ;

   declaredIdentifier = metadata &amp; finalConstVarOrType &amp; identifier;
   variableDeclaration = declaredIdentifier.separatedBy(comma);
   initializedIdentifier = identifier &amp; (equalSign &amp; expression).optional();
   initializedVariableDeclaration = declaredIdentifier &amp; (equalSign &amp; expression).optional() &amp; (comma &amp; initializedIdentifier).star();
   initializedIdentifierList = initializedIdentifier.separatedBy(comma);


   fieldFormalParameter = metadata &amp; finalConstVarOrType.optional() &amp; THIS &amp; dot &amp; identifier;

   simpleFormalParameter =
     declaredIdentifier
   | metadata &amp; identifier
   ;

   normalFormalParameter =
     functionSignature
   | fieldFormalParameter
   | simpleFormalParameter
   ;

   normalFormalParameters = normalFormalParameter.separatedBy(comma);
   defaultFormalParameter = normalFormalParameter &amp; (equalSign &amp; expression).optional();
   defaultNamedParameter = normalFormalParameter &amp; (colon &amp; expression).optional();
   optionalPositionalFormalParameters = _token('[') &amp; defaultFormalParameter.separatedBy(comma) &amp; _token(']');

   optionalFormalParameters =
     optionalPositionalFormalParameters |
     namedFormalParameters
   ;

   formalParameterList =
     lparen &amp; rparen
     | lparen &amp; normalFormalParameters &amp; (comma &amp; optionalFormalParameters).optional() &amp; rparen
     | lparen &amp; optionalFormalParameters &amp; rparen
   ;

   namedFormalParameters = _token('{') &amp; defaultNamedParameter.separatedBy(comma) &amp; _token('}');

   functionSignature = metadata &amp; returnType.optional() &amp; identifier &amp; formalParameterList;
   block = _token('{') &amp; statements &amp; _token('}');

   functionBody =
     _token('=&gt;') &amp; expression &amp; semicolon
     | block
   ;


   interfaces = IMPLEMENTS &amp; typeList;
   superclass = EXTENDS &amp; type;
   ;

   constantConstructorSignature = CONST &amp; qualified &amp; formalParameterList;
   redirectingFactoryConstructorSignature =
     CONST.optional() &amp; FACTORY &amp; identifier &amp; (dot &amp; identifier).optional() &amp;  formalParameterList &amp; equalSign &amp; type &amp; (dot &amp; identifier).optional()
   ;
   factoryConstructorSignature =
       FACTORY &amp; identifier &amp; (dot &amp; identifier).optional() &amp; formalParameterList
   ;


   fieldInitializer = (THIS &amp; dot).optional() &amp; identifier &amp; equalSign &amp; conditionalExpression &amp; cascadeSection.star();
   superCallOrFieldInitializer =
     SUPER &amp; arguments
     | SUPER &amp; dot &amp; identifier &amp; arguments
     | fieldInitializer
   ;

   initializers = colon &amp; superCallOrFieldInitializer.separatedBy(comma);
   redirection = colon &amp; THIS &amp; (dot &amp; identifier).optional() &amp; arguments;
   constructorSignature = identifier &amp; (dot &amp; identifier).optional() &amp; formalParameterList;
   setterSignature = returnType.optional() &amp; SET &amp; identifier &amp; formalParameterList;
   getterSignature = type.optional() &amp; GET &amp; identifier;

   binaryOperator =
     multiplicativeOperator
   | additiveOperator
   | shiftOperator
   | relationalOperator
   | _token('==')
   | bitwiseOperator
   ;

   operator =
     _token('~')
   | binaryOperator
   | _token('[') &amp; _token(']')
   | _token('[') &amp; _token(']') &amp; equalSign
   ;

   operatorSignature = returnType.optional() &amp; OPERATOR &amp; operator &amp; formalParameterList;

   mixins = WITH &amp; typeList;

   methodSignature =
     constructorSignature &amp; initializers.optional()
   | factoryConstructorSignature
   | STATIC.optional() &amp; functionSignature
   | STATIC.optional() &amp; getterSignature
   | STATIC.optional() &amp; setterSignature
   | operatorSignature
   ;

   staticFinalDeclaration = identifier &amp; equalSign &amp; expression;
   staticFinalDeclarationList = staticFinalDeclaration.separatedBy(comma);

   declaration =
     constantConstructorSignature &amp; (redirection | initializers).optional()
   | constructorSignature &amp; (redirection | initializers).optional()
   | EXTERNAL &amp; constantConstructorSignature
   | EXTERNAL &amp; constructorSignature
   | EXTERNAL &amp; factoryConstructorSignature
   | (EXTERNAL &amp; STATIC.optional()).optional() &amp; getterSignature
   | (EXTERNAL &amp; STATIC.optional()).optional() &amp; setterSignature
   | EXTERNAL.optional() &amp; operatorSignature
   | (EXTERNAL &amp; STATIC.optional()).optional() &amp; functionSignature
   | getterSignature
   | setterSignature
   | operatorSignature
   | functionSignature
   | STATIC &amp; (FINAL | CONST) &amp; type.optional() &amp; staticFinalDeclarationList
   | CONST &amp; type.optional() &amp; staticFinalDeclarationList
   | FINAL &amp; type.optional() &amp; initializedIdentifierList
   | STATIC.optional() &amp; (VAR | type) &amp; initializedIdentifierList
   ;



   classMemberDefinition =
     declaration &amp; semicolon
     | methodSignature &amp; functionBody
   ;

   classDefinition =
       metadata &amp; ABSTRACT.optional() &amp; CLASS &amp; identifier &amp; typeParameters.optional() &amp; (superclass &amp; mixins.optional()).optional() &amp; interfaces.optional()
       &amp; _token('{') &amp; (metadata &amp; classMemberDefinition).star() &amp; _token('}')
       ;

   mixinApplication = type &amp; mixins &amp; interfaces.optional();

 }

 void _expressions() {

   IDENTIFIER_START_NO_DOLLAR =
     LETTER
   | _token('_')
   ;

   IDENTIFIER_START =
     IDENTIFIER_START_NO_DOLLAR
   | dollar
   ;

   IDENTIFIER_PART_NO_DOLLAR =
     IDENTIFIER_START_NO_DOLLAR
   | DIGIT
   ;


   IDENTIFIER_PART =
     IDENTIFIER_START
   | DIGIT
   ;

   IDENTIFIER_NO_DOLLAR = IDENTIFIER_START_NO_DOLLAR &amp; IDENTIFIER_PART_NO_DOLLAR.star();

   IDENTIFIER = IDENTIFIER_START &amp; IDENTIFIER_PART.star();

   identifier = IDENTIFIER.flatten().token().trim();
   qualified = identifier.separatedBy(dot);

   assignableSelector =
     _token('[') &amp; expression &amp; _token(']')
   | dot &amp; identifier
   ;

   assignableExpression =
     primary &amp; (arguments.star() &amp; assignableSelector).plus()
   | SUPER &amp; assignableSelector
   | identifier
   ;

   incrementOperator = _token('++') | _token('--');
   selector = assignableSelector | arguments;
   postfixOperator = incrementOperator;

   postfixExpression =
     assignableExpression &amp; postfixOperator
   | primary &amp; selector.star()
   ;

   unaryOperator = _token('!') | _token('~');
   prefixOperator = minus | unaryOperator;
   unaryExpression =
     prefixOperator &amp; unaryExpression
   | postfixExpression
   | prefixOperator &amp; SUPER
   | incrementOperator &amp; assignableExpression
   ;

   multiplicativeOperator = _token('*') | _token('/') | _token('%') | _token('~/');
   multiplicativeExpression =
     unaryExpression &amp; (multiplicativeOperator &amp; unaryExpression).star()
   | SUPER &amp; (multiplicativeOperator &amp; unaryExpression).plus()
   ;

   additiveOperator = pluz | minus;

   additiveExpression =
     multiplicativeExpression &amp; (additiveOperator &amp; multiplicativeExpression).star()
   | SUPER &amp; (additiveOperator &amp; multiplicativeExpression).plus()
   ;

   shiftOperator = _token('&lt;&lt;') | _token('&gt;&gt;');
   shiftExpression =
     additiveExpression &amp; (shiftOperator &amp; additiveExpression).star()
   | SUPER &amp; (shiftOperator &amp; additiveExpression).plus()
   ;

   relationalOperator = _token('&lt;') | _token('&gt;') | _token('&lt;=') | _token('&gt;=');
   relationalExpression =
     shiftExpression &amp; (typeTest | typeCast | relationalOperator &amp; shiftExpression).optional()
   | SUPER &amp; relationalOperator &amp; shiftExpression
   ;

   equalityOperator = _token('==') | _token('!=');
   equalityExpression =
     relationalExpression &amp; (equalityOperator &amp; relationalExpression).optional()
   | SUPER &amp; equalityOperator &amp; relationalExpression
   ;

   bitwiseOperator = _token('|') | _token('&amp;') | _token('^');
   bitwiseAndExpression =
     equalityExpression &amp; (_token('&amp;') &amp; equalityExpression).star()
   | SUPER &amp; (_token('&amp;') &amp; equalityExpression).plus()
   ;
   bitwiseXorExpression =
     bitwiseAndExpression &amp; (_token('^') &amp; bitwiseAndExpression).star()
   | SUPER &amp; (_token('^') &amp; bitwiseAndExpression).plus()
   ;
   bitwiseOrExpression =
       bitwiseXorExpression &amp; (_token('|') &amp; bitwiseXorExpression).star()
       | SUPER &amp; (_token('|') &amp; bitwiseXorExpression).plus()
       ;

   logicalAndExpression = bitwiseOrExpression &amp; (_token('&amp;&amp;') &amp; bitwiseOrExpression).star();
   logicalOrExpression = logicalAndExpression &amp; (_token('||') &amp; logicalAndExpression).star();

   conditionalExpression = logicalOrExpression &amp; (_token('?') &amp; expressionWithoutCascade &amp; colon &amp; expressionWithoutCascade).optional();

   compoundAssignmentOperator =
     _token('*=')
   | _token('/=')
   | _token('~/=')
   | _token('%=')
   | _token('+=')
   | _token('-=')
   | _token('&lt;&lt;=')
   | _token('&gt;&gt;=')
   | _token('&amp;=')
   | _token('^=')
   | _token('|=')
   ;
   assignmentOperator = equalSign | compoundAssignmentOperator;

   cascadeSelector =
     _token('[') &amp; expression &amp; _token(']')
     | identifier
     ;
   cascadeSection =
     _token('..')  &amp;
     (cascadeSelector &amp; arguments.star()) &amp;
     (assignableSelector &amp; arguments.star()).star() &amp;
     (assignmentOperator &amp; expressionWithoutCascade).optional()
   ;

   namedArgument = label &amp; expression;
   argumentList =
     namedArgument.separatedBy(comma)
   | expressionList.separatedBy(comma)
   ;
   arguments = lparen &amp; argumentList.optional() &amp; rparen;

   isOperator = IS &amp; _token('!').optional();
   typeTest = isOperator &amp; type;
   typeCast = AS &amp; type;
   argumentDefinitionTest = _token('?') &amp; identifier;

   constObjectExpression = CONST &amp; type &amp; (dot &amp; identifier).optional() &amp; arguments;
   newExpression = NEW &amp; type &amp; (dot &amp; identifier).optional() &amp; arguments;

   thisExpression = THIS;

   functionExpressionBody =
     _token('=&gt;') &amp; expression
   | block
   ;
   functionExpression = formalParameterList &amp; functionExpressionBody;

   rethrowExpression = RETHROW;
   throwExpression = THROW &amp; expression;
   throwExpressionWithoutCascade = THROW &amp; expressionWithoutCascade;

   mapLiteralEntry = stringLiteral &amp; colon &amp; expression;
   mapLiteral =
     CONST.optional() &amp;
     typeArguments.optional() &amp;
     _token('{') &amp;
     (mapLiteralEntry &amp; (dot &amp; mapLiteralEntry).star() &amp; comma.optional()).optional() &amp;
     _token('}');

   listLiteral =
       CONST.optional() &amp; typeArguments.optional() &amp; _token('[') &amp; (expressionList &amp; comma.optional()).optional() &amp; _token(']');

   stringInterpolation = dollar &amp; IDENTIFIER_NO_DOLLAR |
       dollar &amp; _token('{') &amp; expression &amp; _token('}');
   NEWLINE = _token('\\n') | _token('\r');
   stringContentDQ = (backSlash | doubleQuote | dollar | NEWLINE).not() |
       backSlash &amp; NEWLINE.not() |
       stringInterpolation;
   stringContentSQ = (backSlash | singleQuote | dollar | NEWLINE).not() |
       backSlash &amp; NEWLINE.not() |
       stringInterpolation;
   stringContentTDQ = (backSlash | tripleDoubleQuote | dollar | NEWLINE).not() |
       backSlash &amp; NEWLINE.not() |
       stringInterpolation;
   stringContentTSQ = (backSlash | tripleSingleQuote | dollar | NEWLINE).not() |
       backSlash &amp; NEWLINE.not() |
       stringInterpolation;

   multilineString =
     tripleDoubleQuote &amp; stringContentTDQ.star() &amp; tripleDoubleQuote
     | tripleSingleQuote &amp; stringContentTSQ.star() &amp; tripleSingleQuote
     | _token('r') &amp; tripleDoubleQuote &amp; doubleQuote.not().star() &amp; tripleDoubleQuote
     | _token('r') &amp; tripleSingleQuote &amp; singleQuote.not().star() &amp; tripleSingleQuote
   ;

   singleLineString =
       doubleQuote &amp; stringContentDQ.star() &amp; doubleQuote
       | singleQuote &amp; stringContentSQ.star() &amp; singleQuote
       | _token('r') &amp; doubleQuote &amp; ( doubleQuote | NEWLINE ).not().star() &amp; doubleQuote
       | _token('r') &amp; singleQuote &amp; ( singleQuote | NEWLINE ).not().star() &amp; singleQuote
       ;


   stringLiteral =
     multilineString.plus()
   | singleLineString.plus()
   ;

   numericLiteral =
     NUMBER
     | HEX_NUMBER
   ;

   booleanLiteral =
     TRUE
   | FALSE
   ;

   nullLiteral = NULL;

   literal =
     nullLiteral
   | booleanLiteral
   | numericLiteral
   | stringLiteral
   | mapLiteral
   | listLiteral
   ;

   expression =
     assignableExpression &amp; assignmentOperator &amp; expression
     | conditionalExpression &amp; cascadeSection.star()
     | throwExpression
     | rethrowExpression
   ;



   expressionWithoutCascade =
     assignableExpression &amp; assignmentOperator &amp; expressionWithoutCascade
     | conditionalExpression
     | throwExpressionWithoutCascade
     | rethrowExpression
   ;

   expressionList =  expression.separatedBy(comma);


   primary =
     thisExpression
     | SUPER &amp; assignableSelector
     | functionExpression
     | literal
     | identifier
     | newExpression
     | constObjectExpression
     | lparen &amp; expression &amp; rparen
     | argumentDefinitionTest
   ;

 }

 void _statements() {

   assertStatement = ASSERT &amp; lparen &amp; conditionalExpression &amp; rparen &amp; semicolon;
   continueStatement = CONTINUE &amp; identifier.optional() &amp; semicolon;
   breakStatement = BREAK &amp; identifier.optional() &amp; semicolon;
   label = identifier &amp; colon;
   returnStatement = RETURN &amp; expression.optional() &amp; semicolon;

   finallyPart = FINALLY &amp; block;
   catchPart = CATCH &amp; lparen &amp; identifier &amp; (comma &amp; identifier).optional() &amp; rparen;
   onPart =
       catchPart &amp;  block
       | ON &amp; type &amp; catchPart.optional() &amp; block
   ;

   tryStatement = TRY &amp; block &amp; (onPart.plus() &amp; finallyPart.optional() | finallyPart);

   defaultCase = label.star() &amp; DEFAULT &amp; colon &amp; statements;
   switchCase = label.star() &amp; (CASE &amp; expression &amp; colon) &amp; statements;
   switchStatement = SWITCH &amp; lparen &amp; expression &amp; rparen &amp; _token('{') &amp; switchCase.star() &amp; defaultCase.optional() &amp; _token('}');
   doStatement = DO &amp; statement &amp; WHILE &amp; lparen &amp; expression &amp; rparen &amp; semicolon;
   whileStatement = WHILE &amp; lparen &amp; expression &amp; rparen &amp; statement;

   forInitializerStatement =
     localVariableDeclaration &amp; semicolon
   | expression.optional() &amp; semicolon
   ;

   forLoopParts =
     forInitializerStatement &amp; expression.optional() &amp; semicolon &amp; expressionList.optional()
   | declaredIdentifier &amp; IN &amp; expression
   | identifier &amp; IN &amp; expression
   ;

   forStatement = FOR &amp; lparen &amp; forLoopParts &amp; rparen &amp; statement;
   ifStatement = IF &amp; lparen &amp; expression &amp; rparen &amp; statement &amp; (ELSE &amp; statement).optional();
   localFunctionDeclaration = functionSignature &amp; functionBody;
   localVariableDeclaration = initializedVariableDeclaration &amp; semicolon;
   expressionStatement = expression.optional() &amp; semicolon;

   nonLabelledStatement =
         block
         | localVariableDeclaration &amp; semicolon
         | forStatement
         | whileStatement
         | doStatement
         | switchStatement
         | ifStatement
         | tryStatement
         | breakStatement
         | continueStatement
         | returnStatement
         | expressionStatement
         | assertStatement
         | localFunctionDeclaration;


   statement = label.star() &amp; nonLabelledStatement;
   statements = statement.star();

 }

 void _libraries() {

   uri = stringLiteral;
   getOrSet = GET | SET;

   topLevelDefinition =
       classDefinition
       | mixinApplication
       | typeAlias
       | EXTERNAL &amp; functionSignature
       | EXTERNAL &amp; getterSignature
       | EXTERNAL &amp; setterSignature
       | functionSignature &amp; functionBody
       | returnType.optional() &amp; getOrSet &amp; identifier &amp; formalParameterList &amp; functionBody
       | (FINAL | CONST) &amp; type.optional() &amp; staticFinalDeclarationList &amp; semicolon
       | variableDeclaration &amp; semicolon
       ;

   identifierList = identifier.separatedBy(comma).optional();
   combinator =
       SHOW &amp; identifierList
       | HIDE &amp; identifierList;


   libraryImport = metadata &amp; IMPORT &amp; (AS &amp; identifier).optional() &amp; combinator.star() &amp; semicolon;
   libraryExport = metadata &amp; EXPORT &amp; uri &amp; combinator.star() &amp; semicolon;
   importOrExport = libraryImport | libraryExport;

   libraryName = metadata &amp; LIBRARY &amp; identifier.separatedBy(dot) &amp; semicolon;

   partDirective = metadata &amp; PART &amp; stringLiteral &amp; semicolon;
   partHeader = metadata &amp; PART &amp; OF &amp; identifier.separatedBy(dot) &amp; semicolon;
   partDeclaration = partHeader &amp; topLevelDefinition.star();

   libraryDefinition = libraryName.optional() &amp; importOrExport.star() &amp; partDirective.star() &amp; topLevelDefinition.star();

   scriptTag = _token('#!') &amp; NEWLINE.not().star() &amp; NEWLINE;
   scriptDefinition = scriptTag.optional() &amp; libraryDefinition;

   start = scriptDefinition.end();

 }

}
</pre>
</div>
<h3>Extends</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../petitparser/Parser.html">Parser</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><a href="../petitparser/_DelegateParser.html">_DelegateParser</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><a href="../petitparser/_SetableParser.html">_SetableParser</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><a href="../petitparser/CompositeParser.html">CompositeParser</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><a href="../beta/CompositeParser2.html">CompositeParser2</a></span>&nbsp;&gt;&nbsp;<span class="type-box"><span class="icon-class"></span><strong>DartGrammar</strong></span></p>
<div class="inherited">
<h3>Properties</h3>
<div class="field inherited"><h4 id="children">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../petitparser/Parser.html">Parser</a>&gt;         <strong>children</strong> <a class="anchor-link"
            href="#children"
            title="Permalink to DartGrammar.children">#</a>
        </h4>
        <div class="inherited-from">inherited from <a href="../petitparser/_DelegateParser.html">_DelegateParser</a> </div><div class="doc">
<div class="inherited">
<p>Returns a list of directly referenced parsers.</p>
<p>For example, <code>letter().children</code> returns the empty collection <code>[]</code>,
because the letter parser is a primitive or leaf parser that does not
depend or call any other parser.</p>
<p>In contrast, <code>letter().or(digit()).children</code> returns a collection
containing both the <code>letter()</code> and <code>digit()</code> parser.</p>
<div class="docs-inherited-from">docs inherited from <a href="../petitparser/Parser.html">Parser</a> </div></div>
<pre class="source">
List&lt;Parser&gt; get children =&gt; [_delegate];
</pre>
</div>
</div>
</div>
<div class="inherited">
<h3>Operators</h3>
<div class="method inherited"><h4 id="[]">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>operator []</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> name) <a class="anchor-link" href="#[]"
              title="Permalink to DartGrammar.operator []">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/CompositeParser.html">CompositeParser</a> </div><div class="doc">
<p>Convenience operator returning a reference to a production with
a 
<span class="param">name</span>. See <code>CompositeParser.ref</code> for details.</p>
<pre class="source">
Parser operator [](String name) =&gt; ref(name);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="&">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>operator &</strong>(<a href="../petitparser/Parser.html">Parser</a> other) <a class="anchor-link" href="#&"
              title="Permalink to DartGrammar.operator &">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Convenience operator returning a parser accepts the receiver followed
by 
<span class="param">other</span>. See <code>Parser.seq</code> for details.</p>
<pre class="source">
Parser operator &amp; (Parser other) =&gt; this.seq(other);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="|">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>operator |</strong>(<a href="../petitparser/Parser.html">Parser</a> other) <a class="anchor-link" href="#|"
              title="Permalink to DartGrammar.operator |">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Convenience operator returning a parser accepts the receiver or

<span class="param">other</span>. See <code>Parser.or</code> for details.</p>
<pre class="source">
Parser operator | (Parser other) =&gt; this.or(other);
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method inherited"><h4 id="accept">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> <strong>accept</strong>(input) <a class="anchor-link" href="#accept"
              title="Permalink to DartGrammar.accept">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Tests if the 
<span class="param">input</span> can be successfully parsed.</p>
<p>For example, <code>letter().plus().accept('abc')</code> returns <code>true</code>, and
<code>letter().plus().accept('123')</code> returns <code>false</code>.</p>
<pre class="source">
bool accept(dynamic input) {
 return parse(input).isSuccess;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="action">
<button class="show-code">Code</button>
void <strong>action</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> name, function(Dynamic)) <a class="anchor-link" href="#action"
              title="Permalink to DartGrammar.action">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/CompositeParser.html">CompositeParser</a> </div><div class="doc">
<p>Attaches an action 
<span class="param">function</span> to an existing production 
<span class="param">name</span>. The code
raises an <code>UndefinedProductionError</code> if 
<span class="param">name</span> is an undefined production.
Only call this method from <a class="crossref" href="../dart/DartGrammar.html#initialize">initialize</a>.</p>
<p>The following example attaches an action returning the size of list of
the previously defined list production:</p>
<pre><code>action('list', (list) =&gt; list.length);
</code></pre>
<pre class="source">
void action(String name, dynamic function(Dynamic)) {
 redef(name, (parser) =&gt; parser.map(function));
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="and">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>and</strong>() <a class="anchor-link" href="#and"
              title="Permalink to DartGrammar.and">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a parser (logical and-predicate) that succeeds whenever the
receiver does, but never consumes input.</p>
<p>For example, the parser <code>char('_').and().seq(identifier)</code> accepts
identifiers that start with an underscore character. Since the predicate
does not consume accepted input, the parser <code>identifier</code> is given the
ability to process the complete identifier.</p>
<pre class="source">
Parser and() =&gt; new _AndParser(this);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="copy">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>copy</strong>() <a class="anchor-link" href="#copy"
              title="Permalink to DartGrammar.copy">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/_SetableParser.html">_SetableParser</a> </div><div class="doc">
<div class="inherited">
<p>Returns a shallow copy of the receiver.</p>
<div class="docs-inherited-from">docs inherited from <a href="../petitparser/Parser.html">Parser</a> </div></div>
<pre class="source">
Parser copy() =&gt; new _SetableParser(_delegate);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="def">
<button class="show-code">Code</button>
void <strong>def</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> name, <a href="../petitparser/Parser.html">Parser</a> parser) <a class="anchor-link" href="#def"
              title="Permalink to DartGrammar.def">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/CompositeParser.html">CompositeParser</a> </div><div class="doc">
<p>Defines a production with a 
<span class="param">name</span> and a 
<span class="param">parser</span>. Only call this method
from <a class="crossref" href="../dart/DartGrammar.html#initialize">initialize</a>.</p>
<p>The following example defines a list production that consumes
several elements separated by a comma.</p>
<pre><code>def('list', ref('element').separatedBy(char(',')));
</code></pre>
<pre class="source">
void def(String name, Parser parser) {
 if (_completed) {
   throw new CompletedParserError();
 } else if (_defined.containsKey(name)) {
   throw new RedefinedProductionError(name);
 } else {
   _defined[name] = parser;
 }
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="end">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>end</strong>([<a href="http://api.dartlang.org/dart_core/String.html">String</a> message = 'end of input expected']) <a class="anchor-link" href="#end"
              title="Permalink to DartGrammar.end">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a parser that succeeds only if the receiver consumes the complete
input, otherwise return a failure with the optional 
<span class="param">message</span>.</p>
<p>For example, the parser <code>letter().end()</code> succeeds on the input <code>'a'</code>
and fails on <code>'ab'</code>. In contrast the parser <code>letter()</code> alone would
succeed on both inputs, but not consume everything for the second input.</p>
<pre class="source">
Parser end([String message = 'end of input expected']) {
 return new _EndOfInputParser(this, message);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="flatten">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>flatten</strong>() <a class="anchor-link" href="#flatten"
              title="Permalink to DartGrammar.flatten">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a parser that discards the result of the receiver, and returns
a sub-string of the consumed elements in the string/list being parsed.</p>
<p>For example, the parser <code>letter().plus().flatten()</code> returns <code>'abc'</code>
for the input <code>'abc'</code>. In contrast, the parser <code>letter().plus()</code> would
return <code>['a', 'b', 'c']</code> for the same input instead.</p>
<pre class="source">
Parser flatten() =&gt; new _FlattenParser(this);
</pre>
</div>
</div>
<div class="method"><h4 id="initialize">
<button class="show-code">Code</button>
void <strong>initialize</strong>() <a class="anchor-link" href="#initialize"
              title="Permalink to DartGrammar.initialize">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Initializes the composite grammar.</p>
<div class="docs-inherited-from">docs inherited from <a href="../petitparser/CompositeParser.html">CompositeParser</a> </div></div>
<pre class="source">
void initialize() {
 _whitespace();
 _lexemes();
 _keywords();
 _types();
 _declarations();
 _expressions();
 _statements();
 _libraries();
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="map">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>map</strong>(<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> function) <a class="anchor-link" href="#map"
              title="Permalink to DartGrammar.map">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a parser that evaluates 
<span class="param">function</span> as action handler on success
of the receiver.</p>
<p>For example, the parser <code>digit().map((char) =&gt; int.parse(char))</code> returns
the number <code>1</code> for the input string <code>'1'</code>.</p>
<pre class="source">
Parser map(Function function) =&gt; new _ActionParser(this, function);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="match">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> <strong>match</strong>(<a href="../petitparser/Parser.html">Parser</a> other, [<a href="http://api.dartlang.org/dart_core/Set.html">Set</a>&lt;<a href="../petitparser/Parser.html">Parser</a>&gt; seen]) <a class="anchor-link" href="#match"
              title="Permalink to DartGrammar.match">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Recusively tests for the equality of two parsers.</p>
<p>The code can automatically deals with recursive parsers and parsers that
refer to other parsers. This code is supposed to be overridden by parsers
that add other state.</p>
<pre class="source">
bool match(Parser other, [Set&lt;Parser&gt; seen]) {
 if (seen == null) {
   seen = new Set();
 }
 if (this == other || seen.contains(this)) {
   return true;
 }
 seen.add(this);
 if (runtimeType != other.runtimeType || children.length != other.children.length) {
   return false;
 }
 for (var i = 0; i &lt; children.length; i++) {
   if (!children[i].match(other.children[i], seen)) {
     return false;
   }
 }
 return true;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="matches">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Iterable.html">Iterable</a> <strong>matches</strong>(input) <a class="anchor-link" href="#matches"
              title="Permalink to DartGrammar.matches">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a list of all successful overlapping parses of the 
<span class="param">input</span>.</p>
<p>For example, <code>letter().plus().matches('abc de')</code> results in the list
<code>[['a', 'b', 'c'], ['b', 'c'], ['c'], ['d', 'e'], ['e']]</code>. See
<code>Parser.matchesSkipping</code> to retrieve non-overlapping parse results.</p>
<pre class="source">
Iterable matches(dynamic input) {
 var list = new List();
 and().map((each) =&gt; list.add(each)).seq(any()).or(any()).star().parse(input);
 return list;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="matchesSkipping">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Iterable.html">Iterable</a> <strong>matchesSkipping</strong>(input) <a class="anchor-link" href="#matchesSkipping"
              title="Permalink to DartGrammar.matchesSkipping">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a list of all successful non-overlapping parses of the input.</p>
<p>For example, <code>letter().plus().matchesSkipping('abc de')</code> results in the
list <code>[['a', 'b', 'c'], ['d', 'e']]</code>. See <code>Parser.matches</code> to retrieve
overlapping parse results.</p>
<pre class="source">
Iterable matchesSkipping(dynamic input) {
 var list = new List();
 map((each) =&gt; list.add(each)).or(any()).star().parse(input);
 return list;
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="neg">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>neg</strong>([<a href="http://api.dartlang.org/dart_core/String.html">String</a> message]) <a class="anchor-link" href="#neg"
              title="Permalink to DartGrammar.neg">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a parser that consumes any input token (character), but the
receiver.</p>
<p>For example, the parser <code>letter().neg()</code> accepts any input but a letter.
The parser fails for inputs like <code>'a'</code> or <code>'Z'</code>, but succeeds for
input like <code>'1'</code>, <code>'_'</code> or <code>'$'</code>.</p>
<pre class="source">
Parser neg([String message]) =&gt; not(message).seq(any()).pick(1);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="noSuchMethod">
<button class="show-code">Code</button>
dynamic <strong>noSuchMethod</strong>(<a href="http://api.dartlang.org/dart_core/Invocation.html">Invocation</a> mirror) <a class="anchor-link" href="#noSuchMethod"
              title="Permalink to DartGrammar.noSuchMethod">#</a></h4>
<div class="inherited-from">inherited from <a href="../beta/CompositeParser2.html">CompositeParser2</a> </div><div class="doc">
<div class="inherited">
<p><code>noSuchMethod</code> is invoked when users invoke a non-existant method
on an object. The name of the method and the arguments of the
invocation are passed to <code>noSuchMethod</code> in an <code>Invocation</code>.
If <code>noSuchMethod</code> returns a value, that value becomes the result of
the original invocation.</p>
<p>The default behavior of <code>noSuchMethod</code> is to throw a
<code>noSuchMethodError</code>.</p>
<div class="docs-inherited-from">docs inherited from <a href="http://api.dartlang.org/dart_core/Object.html">Object</a> </div></div>
<pre class="source">
dynamic noSuchMethod(Invocation mirror) {
 String name = MirrorSystem.getName(mirror.memberName);
 if (!name.startsWith('_')) {
   // only consider public members
   if (mirror.isGetter) {
     // productions can be accessed any time
     return ref(name);
   } else if (mirror.isSetter) {
     // production can only be defined during initialization
     return def(name.substring(0, name.length - 1),
       mirror.positionalArguments.first);
   } else if (mirror.isMethod &amp;&amp; mirror.positionalArguments.length == 1) {
     // productions can only be redefined during initialization
     var argument = mirror.positionalArguments.first;
     return argument is Parser ? redef(name, argument) : action(name, argument);
   }
 }
 return super.noSuchMethod(mirror);
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="not">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>not</strong>([<a href="http://api.dartlang.org/dart_core/String.html">String</a> message]) <a class="anchor-link" href="#not"
              title="Permalink to DartGrammar.not">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a parser (logical not-predicate) that succeeds whenever the
receiver fails, but never consumes input.</p>
<p>For example, the parser <code>char('_').not().seq(identifier)</code> accepts
identifiers that do not start with an underscore character. If the parser
<code>char('_')</code> accepts the input, the negation and subsequently the
complete parser fails. Otherwise the parser <code>identifier</code> is given the
ability to process the complete identifier.</p>
<pre class="source">
Parser not([String message]) =&gt; new _NotParser(this, message);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="optional">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>optional</strong>([otherwise]) <a class="anchor-link" href="#optional"
              title="Permalink to DartGrammar.optional">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns new parser that accepts the receiver, if possible. The resulting
parser returns the result of the receiver, or <code>null</code> if not applicable.
The returned value can be provided as an optional argument 
<span class="param">otherwise</span>.</p>
<p>For example, the parser <code>letter().optional()</code> accepts a letter as input
and returns that letter. When given something else the parser succeeds as
well, does not consume anything and returns <code>null</code>.</p>
<pre class="source">
Parser optional([dynamic otherwise]) =&gt; new _OptionalParser(this, otherwise);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="or">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>or</strong>(<a href="../petitparser/Parser.html">Parser</a> other) <a class="anchor-link" href="#or"
              title="Permalink to DartGrammar.or">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a parser that accepts the receiver or 
<span class="param">other</span>. The resulting
parser returns the parse result of the receiver, if the receiver fails
it returns the parse result of 
<span class="param">other</span> (exclusive ordered choice).</p>
<p>For example, the parser <code>letter().or(digit())</code> accepts a letter or a
digit. An example where the order matters is the following choice between
overlapping parsers: <code>letter().or(char('a'))</code>. In the example the parser
<code>char('a')</code> will never be activated, because the input is always consumed
<code>letter()</code>. This can be problematic if the author intended to attach a
production action to <code>char('a')</code>.</p>
<pre class="source">
Parser or(Parser other) =&gt; new _ChoiceParser([this, other]);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="parse">
<button class="show-code">Code</button>
<a href="../petitparser/Result.html">Result</a> <strong>parse</strong>(input) <a class="anchor-link" href="#parse"
              title="Permalink to DartGrammar.parse">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns the parse result of the 
<span class="param">input</span>.</p>
<p>The implementation creates a default parse context on the input and calls
the internal parsing logic of the receiving parser.</p>
<p>For example, <code>letter().plus().parse('abc')</code> results in an instance of
<code>Success</code>, where <code>Result.position</code> is <code>3</code> and <code>Success.value</code> is
<code>[a, b, c]</code>.</p>
<p>Similarly, <code>letter().plus().parse('123')</code> results in an instance of
<code>Failure</code>, where <code>Result.position</code> is <code>0</code> and <code>Failure.message</code> is
<code>'letter expected'</code>.</p>
<pre class="source">
Result parse(dynamic input) {
 return _parse(new Context(input, 0));
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="permute">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>permute</strong>(<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="http://api.dartlang.org/dart_core/int.html">int</a>&gt; indexes) <a class="anchor-link" href="#permute"
              title="Permalink to DartGrammar.permute">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a parser that transforms a successful parse result by returning
the permuted elements at 
<span class="param">indexes</span> of a list. Negative indexes can be
used to access the elements from the back of the list.</p>
<p>For example, the parser <code>letter().star().permute([0, -1])</code> returns the
first and last letter parsed. For the input <code>'abc'</code> it returns
<code>['a', 'c']</code>.</p>
<pre class="source">
Parser permute(List&lt;int&gt; indexes) {
 return this.map((List list) {
   return indexes.map((index) {
     return list[index &lt; 0 ? list.length + index : index];
   }).toList();
 });
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="pick">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>pick</strong>(<a href="http://api.dartlang.org/dart_core/int.html">int</a> index) <a class="anchor-link" href="#pick"
              title="Permalink to DartGrammar.pick">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a parser that transform a successful parse result by returning
the element at 
<span class="param">index</span> of a list. A negative index can be used to access
the elements from the back of the list.</p>
<p>For example, the parser <code>letter().star().pick(-1)</code> returns the last
letter parsed. For the input <code>'abc'</code> it returns <code>'c'</code>.</p>
<pre class="source">
Parser pick(int index) {
 return this.map((List list) {
   return list[index &lt; 0 ? list.length + index : index];
 });
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="plus">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>plus</strong>() <a class="anchor-link" href="#plus"
              title="Permalink to DartGrammar.plus">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a parser that accepts the receiver one or more times. The
resulting parser returns a list of the parse results of the receiver.</p>
<p>This is a greedy and blind implementation that tries to consume as much
input as possible and that does not consider what comes afterwards.</p>
<p>For example, the parser <code>letter().plus()</code> accepts any sequence of
letters and returns a list of the parsed letters.</p>
<pre class="source">
Parser plus() =&gt; repeat(1, 65536);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="redef">
<button class="show-code">Code</button>
void <strong>redef</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> name, replacement) <a class="anchor-link" href="#redef"
              title="Permalink to DartGrammar.redef">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/CompositeParser.html">CompositeParser</a> </div><div class="doc">
<p>Redefinies an existing production with a 
<span class="param">name</span> and a 
<span class="param">replacement</span>
parser or function producing a new parser. The code raises an
<code>UndefinedProductionError</code> if 
<span class="param">name</span> is an undefined production. Only call
this method from <a class="crossref" href="../dart/DartGrammar.html#initialize">initialize</a>.</p>
<p>The following example redefines the previously defined list production
by making it optional:</p>
<pre><code>redef('list', (parser) =&gt; parser.optional());
</code></pre>
<pre class="source">
void redef(String name, dynamic replacement) {
 if (_completed) {
   throw new CompletedParserError();
 } else if (!_defined.containsKey(name)) {
   throw new UndefinedProductionError(name);
 } else {
   _defined[name] = replacement is Parser ? replacement
       : replacement(_defined[name]);
 }
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="ref">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>ref</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> name) <a class="anchor-link" href="#ref"
              title="Permalink to DartGrammar.ref">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/CompositeParser.html">CompositeParser</a> </div><div class="doc">
<p>Returns a reference to a production with a 
<span class="param">name</span>.</p>
<p>This method works during initialization and after completion of the
initialization. During the initialization it returns delegate parsers
that are eventually replaced by the real parsers. Afterwards it
returns the defined parser (mostly useful for testing).</p>
<pre class="source">
Parser ref(String name) {
 if (_completed) {
   if (_defined.containsKey(name)) {
     return _defined[name];
   } else {
     throw new UndefinedProductionError(name);
   }
 } else {
   return _undefined.putIfAbsent(name, () {
     return failure('Uninitalized production: $name').setable();
   });
 }
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="repeat">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>repeat</strong>(<a href="http://api.dartlang.org/dart_core/int.html">int</a> min, <a href="http://api.dartlang.org/dart_core/int.html">int</a> max) <a class="anchor-link" href="#repeat"
              title="Permalink to DartGrammar.repeat">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a parser that accepts the receiver between 
<span class="param">min</span> and 
<span class="param">max</span> times.
The resulting parser returns a list of the parse results of the receiver.</p>
<p>This is a greedy and blind implementation that tries to consume as much
input as possible and that does not consider what comes afterwards.</p>
<p>For example, the parser <code>letter().repeat(2, 4)</code> accepts a sequence of
two, three, or four letters and returns the accepted letters as a list.</p>
<pre class="source">
Parser repeat(int min, int max) =&gt; new _RepeatingParser(this, min, max);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="replace">
<button class="show-code">Code</button>
void <strong>replace</strong>(<a href="../petitparser/Parser.html">Parser</a> source, <a href="../petitparser/Parser.html">Parser</a> target) <a class="anchor-link" href="#replace"
              title="Permalink to DartGrammar.replace">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/_DelegateParser.html">_DelegateParser</a> </div><div class="doc">
<div class="inherited">
<p>Changes the receiver by replacing 
<span class="param">source</span> with 
<span class="param">target</span>. Does nothing
if 
<span class="param">source</span> does not exist in <code>Parser.children</code>.</p>
<p>The following example creates a letter parser and then defines a parser
called <code>example</code> that accepts one or more letters. Eventually the parser
<code>example</code> is modified by replacing the <code>letter</code> parser with a new
parser that accepts a digit. The resulting <code>example</code> parser accepts one
or more digits.</p>
<pre><code>var letter = letter();
var example = letter.plus();
example.replace(letter, digit());
</code></pre>
<div class="docs-inherited-from">docs inherited from <a href="../petitparser/Parser.html">Parser</a> </div></div>
<pre class="source">
void replace(Parser source, Parser target) {
 super.replace(source, target);
 if (_delegate == source) {
   _delegate = target;
 }
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="separatedBy">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>separatedBy</strong>(<a href="../petitparser/Parser.html">Parser</a> separator, {<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> includeSeparators: true, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> optionalSeparatorAtEnd: false}) <a class="anchor-link" href="#separatedBy"
              title="Permalink to DartGrammar.separatedBy">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a parser that consumes the receiver one or more times separated
by the 
<span class="param">separator</span> parser. The resulting parser returns a flat list of
the parse results of the receiver interleaved with the parse result of the
separator parser.</p>
<p>If the optional argument 
<span class="param">includeSeparators</span> is set to <code>false</code>, then the
separators are not included in the parse result. If the optional argument

<span class="param">optionalSeparatorAtEnd</span> is set to <code>true</code> the parser also accepts an
optional separator at the end.</p>
<p>For example, the parser <code>digit().separatedBy(char('-'))</code> returns a parser
that consumes input like <code>'1-2-3'</code> and returns a list of the elements and
separators: <code>['1', '-', '2', '-', '3']</code>.</p>
<pre class="source">
Parser separatedBy(Parser separator, {bool includeSeparators: true,
   bool optionalSeparatorAtEnd: false}) {
 var repeater = new _SequenceParser([separator, this]).star();
 var parser = new _SequenceParser(optionalSeparatorAtEnd
     ? [this, repeater, separator.optional(separator)]
     : [this, repeater]);
 return parser.map((List list) {
   var result = new List();
   result.add(list[0]);
   for (var tuple in list[1]) {
     if (includeSeparators) {
       result.add(tuple[0]);
     }
     result.add(tuple[1]);
   }
   if (includeSeparators &amp;&amp; optionalSeparatorAtEnd
       &amp;&amp; !identical(list[2], separator)) {
     result.add(list[2]);
   }
   return result;
 });
}
</pre>
</div>
</div>
<div class="method inherited"><h4 id="seq">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>seq</strong>(<a href="../petitparser/Parser.html">Parser</a> other) <a class="anchor-link" href="#seq"
              title="Permalink to DartGrammar.seq">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a parser that accepts the receiver followed by 
<span class="param">other</span>. The
resulting parser returns a list of the parse result of the receiver
followed by the parse result of 
<span class="param">other</span>. Calling this method on an
existing sequence code not nest this sequence into a new one, but
instead augments the existing sequence with 
<span class="param">other</span>.</p>
<p>For example, the parser <code>letter().seq(digit()).seq(letter())</code> accepts a
letter followed by a digit and another letter. The parse result of the
input string <code>'a1b'</code> is the list <code>['a', '1', 'b']</code>.</p>
<pre class="source">
Parser seq(Parser other) =&gt; new _SequenceParser([this, other]);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="set">
<button class="show-code">Code</button>
void <strong>set</strong>(<a href="../petitparser/Parser.html">Parser</a> parser) <a class="anchor-link" href="#set"
              title="Permalink to DartGrammar.set">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/_SetableParser.html">_SetableParser</a> </div><div class="doc">
<div class="inherited">
<p>Sets the receiver to delegate to 
<span class="param">parser</span>. </p>
<div class="docs-inherited-from">docs inherited from <a href="../petitparser/SetableParser.html">SetableParser</a> </div></div>
<pre class="source">
void set(Parser parser) =&gt; replace(children[0], parser);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="setable">
<button class="show-code">Code</button>
<a href="../petitparser/SetableParser.html">SetableParser</a> <strong>setable</strong>() <a class="anchor-link" href="#setable"
              title="Permalink to DartGrammar.setable">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a parser that points to the receiver, but can be changed to point
to something else at a later point in time.</p>
<p>For example, the parser <code>letter().setable()</code> behaves exactly the same
as <code>letter()</code>, but it can be replaced with another parser using
<code>SetableParser.set</code>.</p>
<pre class="source">
SetableParser setable() =&gt; new _SetableParser(this);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="star">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>star</strong>() <a class="anchor-link" href="#star"
              title="Permalink to DartGrammar.star">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a parser that accepts the receiver zero or more times. The
resulting parser returns a list of the parse results of the receiver.</p>
<p>This is a greedy and blind implementation that tries to consume as much
input as possible and that does not consider what comes afterwards.</p>
<p>For example, the parser <code>letter().star()</code> accepts the empty string or
any sequence of letters and returns a possibly empty list of the parsed
letters.</p>
<pre class="source">
Parser star() =&gt; repeat(0, 65536);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="times">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>times</strong>(<a href="http://api.dartlang.org/dart_core/int.html">int</a> count) <a class="anchor-link" href="#times"
              title="Permalink to DartGrammar.times">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a parser that accepts the receiver exactly 
<span class="param">count</span> times. The
resulting parser returns a list of the parse results of the receiver.</p>
<p>For example, the parser <code>letter().times(2)</code> accepts two letters and
returns a list of the two parsed letters.</p>
<pre class="source">
Parser times(int count) =&gt; repeat(count, count);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="token">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>token</strong>() <a class="anchor-link" href="#token"
              title="Permalink to DartGrammar.token">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a parser that discards the result of the receiver and returns
a <code>Token</code>. The token carries information about where the token started and
stopped in the input stream.</p>
<p>For example, the parser <code>letter().plus().token()</code> returns the token
<code>Token[start: 0, stop: 3, value: abc]</code> for the input <code>'abc'</code>.</p>
<pre class="source">
Parser token() =&gt; new _TokenParser(this);
</pre>
</div>
</div>
<div class="method inherited"><h4 id="trim">
<button class="show-code">Code</button>
<a href="../petitparser/Parser.html">Parser</a> <strong>trim</strong>([<a href="../petitparser/Parser.html">Parser</a> trimmer]) <a class="anchor-link" href="#trim"
              title="Permalink to DartGrammar.trim">#</a></h4>
<div class="inherited-from">inherited from <a href="../petitparser/Parser.html">Parser</a> </div><div class="doc">
<p>Returns a parser that consumes input before and after the receiver. The
optional argument 
<span class="param">trimmer</span> is a parser that consumes the excess input. By
default <code>whitespace()</code> is used.</p>
<p>For example, the parser <code>letter().plus().trim()</code> returns <code>['a', 'b']</code>
for the input <code>' ab\n'</code> and consumes the complete input string.</p>
<pre class="source">
Parser trim([Parser trimmer]) {
 return new _TrimmingParser(this, trimmer == null ? whitespace() : trimmer);
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
