        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>petitparser Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="favicon.ico">
        
        </head>
        <body data-library="petitparser">
        <div class="page">
        <div class="header">
          <a href="index.html"><div class="logo"></div></a>
          <a href="index.html">Dart Documentation</a>
         &rsaquo; <a href="petitparser.html">petitparser</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
<h2><strong>petitparser</strong> library</h2>
<div class="doc"><h1>Writing a Simple Grammar</h1>
<p>Writing grammars with PetitParser is simple as writing Dart code. For
example, to write a grammar that can parse identifiers that start with
a letter followed by zero or more letter or digits is defined as follows:</p>
<pre><code>Parser id = letter().seq(letter().or(digit()).star());
</code></pre>
<p>If you look at the object <code>id</code> in the debugger, you'll notice
that the code above buils a tree of parser objects:</p><ul><li>Sequence: This parser accepts a sequence of parsers.</li><li><ul><li>Predicate: This parser accepts a single letter.</li></ul></li><li><ul><li>Repeater: This parser accepts zero or more times another parser.</li></ul></li><li><ul><li><ul><li>Choice: This parser accepts a single word character.</li></ul></li></ul></li><li><ul><li><ul><li><ul><li>Predicate: This parser accepts a single letter.</li></ul></li></ul></li></ul></li><li><ul><li><ul><li><ul><li>Predicate: This parser accepts a single digit.</li></ul></li></ul></li></ul></li></ul>
<h1>Parsing Some Input</h1>
<p>To actually parse a <code>String</code> (or <code>List</code>) we can use the method
<a class="crossref" href="petitparser/Parser.html#parse">Parser.parse</a>:</p>
<pre><code>Result id1 = id.parse('yeah');
Result id2 = id.parse('f12');
</code></pre>
<p>The method <a class="crossref" href="petitparser/Parser.html#parse">Parser.parse</a> returns a parse <a class="crossref" href="petitparser/Result.html">Result</a>, which is either an
instance of <a class="crossref" href="petitparser/Success.html">Success</a> or <a class="crossref" href="petitparser/Failure.html">Failure</a>. In both examples above we are
successful and can retrieve the parse result using <a class="crossref" href="petitparser/Success.html#result">Success.result</a>:</p>
<pre><code>print(id1.result);                  // ['y', ['e', 'a', 'h']]
print(id2.result);                  // ['f', ['1', '2']]
</code></pre>
<p>While it seems odd to get these nested arrays with characters as a return
value, this is the default decomposition of the input into a parse tree.
We'll see in a while how that can be customized.</p>
<p>If we try to parse something invalid we get an instance of <a class="crossref" href="petitparser/Failure.html">Failure</a> as
an answer and we can retrieve a descriptive error message using
<a class="crossref" href="petitparser/Failure.html#message">Failure.message</a>:</p>
<pre><code>Result id3 = id.parse('123');
print(id3.message);                // 'letter expected'
print(id3.position);               // 0
</code></pre>
<p>Trying to retrieve the parse result by calling <a class="crossref" href="petitparser/Failure.html#result">Failure.result</a> would throw
the exception <code>UnsupportedError</code>. <a class="crossref" href="petitparser/Result.html#isSuccess">Result.isSuccess</a> and <a class="crossref" href="petitparser/Result.html#isFailure">Result.isFailure</a>
can be used to decide if the parse was successful.</p>
<p>If you are only interested if a given string matches or not you can use the
helper method <a class="crossref" href="petitparser/Parser.html#accept">Parser.accept</a>:</p>
<pre><code>print(id.accept('foo'));            // true
print(id.accept('123'));            // false
</code></pre>
<h1>Different Kinds of Parsers</h1>
<p>PetitParser provide a large set of ready-made parser that you can compose
to consume and transform arbitrarily complex languages. The terminal parsers
are the most simple ones. We've already seen a few of those:</p><ul><li><code>char('a')</code> parses the character <em>a</em>.</li><li><code>string('abc')</code> parses the string <em>abc</em>.</li><li><code>any()</code> parses any character.</li><li><code>digit()</code> parses any digit from <em>0</em> to <em>9</em>.</li><li><code>letter()</code> parses any letter from <em>a</em> to <em>z</em> and <em>A</em> to <em>Z</em>.</li><li><code>word()</code> parses any letter or digit.</li></ul>
<p>So instead of using the letter and digit predicate, we could have written
our identifier parser like this:</p>
<pre><code>var id = letter().seq(word().star());
</code></pre>
<p>The next set of parsers are used to combine other parsers together:</p><ul><li><code>p1.seq(p2)</code> and <code>p1 &amp; p2</code> parse <em>p1</em> followed by <em>p2</em> (sequence).</li><li><code>p1.or(p2)</code> and <code>p1 | p2</code> parse <em>p1</em>, if that doesn't work parses <em>p2</em> (ordered choice).</li><li><code>p.star()</code> parses <em>p</em> zero or more times.</li><li><code>p.plus()</code> parses <em>p</em> one or more times.</li><li><code>p.optional()</code> parses <em>p</em>, if possible.</li><li><code>p.and()</code> parses <em>p</em>, but does not consume its input.</li><li><code>p.not()</code> parses <em>p</em> and succeed when p fails, but does not consume its input.</li><li><code>p.end()</code> parses <em>p</em> and succeed at the end of the input.</li></ul>
<p>To attach an action or transformation to a parser we can use the following
methods:</p><ul><li><code>p.map((value) =&gt; ...)</code> performs the transformation given the function.</li><li><code>p.pick(n)</code> returns the <em>n</em>-th element of the list <em>p</em> returns.</li><li><code>p.flatten()</code> creates a string from the result of <em>p</em>.</li><li><code>p.token()</code> creates a token from the result of <em>p</em>.</li><li><code>p.trim()</code> trims whitespaces before and after <em>p</em>.</li></ul>
<p>To return a string of the parsed identifier, we can modify our parser like
this:</p>
<pre><code>var id = letter().seq(word().star()).flatten();
</code></pre>
<p>To conveniently find all matches in a given input string you can use
<a class="crossref" href="petitparser/Parser.html#matchesSkipping">Parser.matchesSkipping</a>:</p>
<pre><code>var matches = id.matchesSkipping('foo 123 bar4');
print(matches);                    // ['foo', 'bar4']
</code></pre>
<p>These are the basic elements to build parsers. There are a few more well
documented and tested factory methods in the <a class="crossref" href="petitparser/Parser.html">Parser</a> class. If you want
browse their documentation and tests.</p>
<h1>Writing a More Complicated Grammar</h1>
<p>Now we are able to write a more complicated grammar for evaluating simple
arithmetic expressions. Within a file we start with the grammar for a
number (actually an integer):</p>
<pre><code>var number = digit().plus().flatten().trim().map(int.parse);
</code></pre>
<p>Then we define the productions for addition and multiplication in order of
precedence. Note that we instantiate the productions with undefined parsers
upfront, because they recursively refer to each other. Later on we can
resolve this recursion by setting their reference:</p>
<pre><code>var term = undefined();
var prod = undefined();
var prim = undefined();

term.set(prod.seq(char('+').trim()).seq(term).map((values) {
  return values[0] + values[2];
}).or(prod));
prod.set(prim.seq(char('*').trim()).seq(prod).map((values) {
  return values[0] * values[2];
}).or(prim));
prim.set(char('(').trim().seq(term).seq(char(')'.trim())).map((values) {
  return values[1];
}).or(number));
</code></pre>
<p>To make sure that our parser consumes all input we wrap it with the <code>end()</code>
parser into the start production:</p>
<pre><code>var start = term.end();
</code></pre>
<p>That's it, now we can test our parser and evaluator:</p>
<pre><code>print(start.parse('1 + 2 * 3').result);       // 7
print(start.parse('(1 + 2) * 3').result);     // 9
</code></pre>
<p>As an exercise we could extend the parser to also accept negative numbers
and floating point numbers, not only integers. Furthermore it would be
useful to support subtraction and division as well. All these features
can be added with a few lines of PetitParser code.</p></div>
<div>
<h3>Functions</h3>
<div class="method"><h4 id="stringIgnoreCase">
<button class="show-code">Code</button>
<a href="petitparser/Parser.html">Parser</a> <strong>stringIgnoreCase</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> element, {<a href="http://api.dartlang.org/dart_core/String.html">String</a> message}) <a class="anchor-link" href="#stringIgnoreCase"
              title="Permalink to stringIgnoreCase">#</a></h4>
<div class="doc">
<p>Returns a parser that accepts the string 
<span class="param">element</span> ignoring the case.</p>
<p>For example, <code>stringIgnoreCase('foo')</code> succeeds and consumes the input
string <code>'Foo'</code> or <code>'FOO'</code>. Fails for any other input.</p>
<pre class="source">
Parser stringIgnoreCase(String element, {String message}) {
 final lowerElement = element.toLowerCase();
 return new _PredicateParser(element.length,
   (String each) =&gt; lowerElement == each.toLowerCase(),
   message != null ? message : '$element expected');
}
</pre>
</div>
</div>
<div class="method"><h4 id="string">
<button class="show-code">Code</button>
<a href="petitparser/Parser.html">Parser</a> <strong>string</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> element, {<a href="http://api.dartlang.org/dart_core/String.html">String</a> message}) <a class="anchor-link" href="#string"
              title="Permalink to string">#</a></h4>
<div class="doc">
<p>Returns a parser that accepts the string 
<span class="param">element</span>.</p>
<p>For example, <code>string('foo')</code> succeeds and consumes the input string
<code>'foo'</code>. Fails for any other input.</p>
<pre class="source">
Parser string(String element, {String message}) {
 return new _PredicateParser(element.length,
   (String each) =&gt; element == each,
   message != null ? message : '$element expected');
}
</pre>
</div>
</div>
<div class="method"><h4 id="anyIn">
<button class="show-code">Code</button>
<a href="petitparser/Parser.html">Parser</a> <strong>anyIn</strong>(elements, {<a href="http://api.dartlang.org/dart_core/String.html">String</a> message}) <a class="anchor-link" href="#anyIn"
              title="Permalink to anyIn">#</a></h4>
<div class="doc">
<p>Returns a parser that accepts any of the 
<span class="param">elements</span>.</p>
<p>For example, <code>anyIn('ab')</code> succeeds and consumes either the letter
<code>'a'</code> or the letter <code>'b'</code>. For any other input the parser fails.</p>
<pre class="source">
Parser anyIn(dynamic elements, {String message}) {
 return new _PredicateParser(1,
   (each) =&gt; elements.indexOf(each) &gt;= 0,
   message != null ? message : 'any of $elements expected');
}
</pre>
</div>
</div>
<div class="method"><h4 id="any">
<button class="show-code">Code</button>
<a href="petitparser/Parser.html">Parser</a> <strong>any</strong>({<a href="http://api.dartlang.org/dart_core/String.html">String</a> message}) <a class="anchor-link" href="#any"
              title="Permalink to any">#</a></h4>
<div class="doc">
<p>Returns a parser that accepts any input element.</p>
<p>For example, <code>any()</code> succeeds and consumes any given letter. It only
fails for an empty input.</p>
<pre class="source">
Parser any({String message}) {
 return new _PredicateParser(1,
   (each) =&gt; true,
   message != null ? message : 'input expected');
}
</pre>
</div>
</div>
<div class="method"><h4 id="undefined">
<button class="show-code">Code</button>
<a href="petitparser/SetableParser.html">SetableParser</a> <strong>undefined</strong>({<a href="http://api.dartlang.org/dart_core/String.html">String</a> message: 'undefined parser'}) <a class="anchor-link" href="#undefined"
              title="Permalink to undefined">#</a></h4>
<div class="doc">
<p>Returns a parser that is not defined, but that can be set at a later
point in time.</p>
<p>For example, the following code sets up a parser that points to itself
and that accepts a sequence of a's ended with the letter b.</p>
<pre><code>var p = undefined();
p.set(char('a').seq(p).or(char('b')));
</code></pre>
<pre class="source">
SetableParser undefined({String message: 'undefined parser'}) {
 return failure(message).setable();
}
</pre>
</div>
</div>
<div class="method"><h4 id="failure">
<button class="show-code">Code</button>
<a href="petitparser/Parser.html">Parser</a> <strong>failure</strong>([<a href="http://api.dartlang.org/dart_core/String.html">String</a> message = 'unable to parse']) <a class="anchor-link" href="#failure"
              title="Permalink to failure">#</a></h4>
<div class="doc">
<p>Returns a parser that consumes nothing and fails.</p>
<p>For example, <code>failure()</code> always fails, no matter what input it is given.</p>
<pre class="source">
Parser failure([String message = 'unable to parse']) {
 return new _FailureParser(message);
}
</pre>
</div>
</div>
<div class="method"><h4 id="epsilon">
<button class="show-code">Code</button>
<a href="petitparser/Parser.html">Parser</a> <strong>epsilon</strong>({result}) <a class="anchor-link" href="#epsilon"
              title="Permalink to epsilon">#</a></h4>
<div class="doc">
<p>Returns a parser that consumes nothing and succeeds.</p>
<p>For example, <code>char('a').or(epsilon())</code> is equivalent to
<code>char('a').optional()</code>.</p>
<pre class="source">
Parser epsilon({dynamic result}) =&gt; new _EpsilonParser(result);
</pre>
</div>
</div>
<div class="method"><h4 id="word">
<button class="show-code">Code</button>
<a href="petitparser/Parser.html">Parser</a> <strong>word</strong>({<a href="http://api.dartlang.org/dart_core/String.html">String</a> message}) <a class="anchor-link" href="#word"
              title="Permalink to word">#</a></h4>
<div class="doc">
<p>Returns a parser that accepts any word character. </p>
<pre class="source">
Parser word({String message}) {
 return new _WordParser(message != null ? message : 'letter or digit expected');
}
</pre>
</div>
</div>
<div class="method"><h4 id="whitespace">
<button class="show-code">Code</button>
<a href="petitparser/Parser.html">Parser</a> <strong>whitespace</strong>({<a href="http://api.dartlang.org/dart_core/String.html">String</a> message}) <a class="anchor-link" href="#whitespace"
              title="Permalink to whitespace">#</a></h4>
<div class="doc">
<p>Returns a parser that accepts any whitespace character. </p>
<pre class="source">
Parser whitespace({String message}) {
 return new _WhitespaceParser(message != null ? message : 'whitespace expected');
}
</pre>
</div>
</div>
<div class="method"><h4 id="uppercase">
<button class="show-code">Code</button>
<a href="petitparser/Parser.html">Parser</a> <strong>uppercase</strong>({<a href="http://api.dartlang.org/dart_core/String.html">String</a> message}) <a class="anchor-link" href="#uppercase"
              title="Permalink to uppercase">#</a></h4>
<div class="doc">
<p>Returns a parser that accepts any uppercase character. </p>
<pre class="source">
Parser uppercase({String message}) {
 return new _UppercaseParser(message != null ? message : 'uppercase letter expected');
}
</pre>
</div>
</div>
<div class="method"><h4 id="range">
<button class="show-code">Code</button>
<a href="petitparser/Parser.html">Parser</a> <strong>range</strong>(start, stop, {<a href="http://api.dartlang.org/dart_core/String.html">String</a> message}) <a class="anchor-link" href="#range"
              title="Permalink to range">#</a></h4>
<div class="doc">
<p>Returns a parser that accepts any character in the range between 
<span class="param">start</span> and 
<span class="param">stop</span>. </p>
<pre class="source">
Parser range(dynamic start, dynamic stop, {String message}) {
 return new _RangeParser( message != null ? message : '$start..$stop expected', _toCharCode(start), _toCharCode(stop));
}
</pre>
</div>
</div>
<div class="method"><h4 id="pattern">
<button class="show-code">Code</button>
<a href="petitparser/Parser.html">Parser</a> <strong>pattern</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> element, {<a href="http://api.dartlang.org/dart_core/String.html">String</a> message}) <a class="anchor-link" href="#pattern"
              title="Permalink to pattern">#</a></h4>
<div class="doc">
<p>Returns a parser that accepts the given character class pattern. </p>
<pre class="source">
Parser pattern(String element, {String message}) {
 if (_pattern == null) {
   final single = any().map((each) {
     return char(each);
   });
   final multiple = any().seq(char('-')).seq(any()).map((each) {
     return range(each[0], each[2]);
   });
   final positive = multiple.or(single).plus().map((each) {
     return each.length == 1 ? each[0] : new _AlternativeCharacterParser(each);
   });
   _pattern = char('^').optional().seq(positive).map((each) {
     return each[0] == null ? each[1] : each[1].neg();
   });
 }
 var parser = _pattern.parse(element).result;
 parser._message = message != null ? message : '[$element] expected';
 return parser;
}
</pre>
</div>
</div>
<div class="method"><h4 id="lowercase">
<button class="show-code">Code</button>
<a href="petitparser/Parser.html">Parser</a> <strong>lowercase</strong>({<a href="http://api.dartlang.org/dart_core/String.html">String</a> message}) <a class="anchor-link" href="#lowercase"
              title="Permalink to lowercase">#</a></h4>
<div class="doc">
<p>Returns a parser that accepts any lowercase character. </p>
<pre class="source">
Parser lowercase({String message}) {
 return new _LowercaseParser(message != null ? message : 'lowercase letter expected');
}
</pre>
</div>
</div>
<div class="method"><h4 id="letter">
<button class="show-code">Code</button>
<a href="petitparser/Parser.html">Parser</a> <strong>letter</strong>({<a href="http://api.dartlang.org/dart_core/String.html">String</a> message}) <a class="anchor-link" href="#letter"
              title="Permalink to letter">#</a></h4>
<div class="doc">
<p>Returns a parser that accepts any letter character. </p>
<pre class="source">
Parser letter({String message}) {
 return new _LetterParser(message != null ? message : 'letter expected');
}
</pre>
</div>
</div>
<div class="method"><h4 id="digit">
<button class="show-code">Code</button>
<a href="petitparser/Parser.html">Parser</a> <strong>digit</strong>({<a href="http://api.dartlang.org/dart_core/String.html">String</a> message}) <a class="anchor-link" href="#digit"
              title="Permalink to digit">#</a></h4>
<div class="doc">
<p>Returns a parser that accepts any digit character. </p>
<pre class="source">
Parser digit({String message}) {
 return new _DigitParser(message != null ? message : 'digit expected');
}
</pre>
</div>
</div>
<div class="method"><h4 id="char">
<button class="show-code">Code</button>
<a href="petitparser/Parser.html">Parser</a> <strong>char</strong>(element, {<a href="http://api.dartlang.org/dart_core/String.html">String</a> message}) <a class="anchor-link" href="#char"
              title="Permalink to char">#</a></h4>
<div class="doc">
<p>Returns a parser that accepts a specific character only. </p>
<pre class="source">
Parser char(dynamic element, {String message}) {
 return new _CharParser(message != null ? message : '$element expected', _toCharCode(element));
}
</pre>
</div>
</div>
</div>
<div>
<h3>Abstract Classes</h3>
          <div class="type">
          <h4>
            <a href="petitparser/CompositeParser.html"><strong>CompositeParser</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="petitparser/Parser.html"><strong>Parser</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="petitparser/Result.html"><strong>Result</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="petitparser/SetableParser.html"><strong>SetableParser</strong></a>
          </h4>
          </div>
          
</div>
<div>
<h3>Classes</h3>
          <div class="type">
          <h4>
            <a href="petitparser/CompositeParser2.html"><strong>CompositeParser2</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="petitparser/Context.html"><strong>Context</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="petitparser/Failure.html"><strong>Failure</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="petitparser/ParserIterable.html"><strong>ParserIterable</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="petitparser/ParserIterator.html"><strong>ParserIterator</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="petitparser/Success.html"><strong>Success</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="petitparser/Token.html"><strong>Token</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="petitparser/Transformations.html"><strong>Transformations</strong></a>
          </h4>
          </div>
          
</div>
<div>
<h3>Exceptions</h3>
          <div class="type">
          <h4>
            <a href="petitparser/CompletedParserError.html"><strong>CompletedParserError</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="petitparser/ParserError.html"><strong>ParserError</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="petitparser/RedefinedProductionError.html"><strong>RedefinedProductionError</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="petitparser/UndefinedProductionError.html"><strong>UndefinedProductionError</strong></a>
          </h4>
          </div>
          
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="client-live-nav.js"></script>
        </body></html>
        
